\documentclass[pdftex]{article}
\usepackage[a4paper,centering,
left=1cm,right=1cm,
top=1.5cm,bottom=2cm,
nohead,nomarginpar]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{framed}
\usepackage[hyperref]{xcolor}
\usepackage{ifthen}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{mathrsfs}
\usepackage[hyperindex]{hyperref}
\usepackage{makeidx}
\usepackage[stable]{footmisc}
\usepackage{titlesec}
\usepackage[nottoc]{tocbibind}
\usepackage{units}
\usepackage{tabularx}
\usepackage[titles]{tocloft}
\usepackage{lmodern}
\usepackage{framed}
\usepackage{xspace}
\definecolor{bg-color}{rgb}{0.96,1,0.95}
\definecolor{shadecolor}{rgb}{0.96,1,0.95}
\definecolor{txt-color}{HTML}{000000}
\definecolor{builtin}{HTML}{DA70D6}
\definecolor{comment}{HTML}{B22222}
\definecolor{comment-delimiter}{HTML}{B22222}
\definecolor{constant}{HTML}{5F9EA0}
\definecolor{function-name}{HTML}{0000FF}
\definecolor{keyword}{HTML}{a020F0}
\definecolor{string}{HTML}{BC8F8F}
\definecolor{type}{HTML}{228B22}
\definecolor{variable-name}{HTML}{B8860B}
\definecolor{brick}{HTML}{7B0C00}

\hypersetup{%
  a4paper,
  colorlinks=true,
  filecolor=blue,
  linkcolor=brick,urlcolor=red,
  pdfstartview=Fit,
  pdfauthor={Philippe Ivaldi},
  pdfsubject={Géométrie plane avec Asymptote},
  pdftitle={Module de géométrie plane pour Asymptote},
  pdfkeywords={géométrie , plane, logiciel, module, package, extension, paquet,
    vectoriel, latex, asymptote, figures, dessin, metapost},
  pdfcreator={moteur:pdfLaTeX, éditeur:Emacs}}
\usepackage[frenchb]{babel}
\frenchbsetup{ReduceListSpacing=false,CompactItemize=false}
% \frenchbsetup{StandardItemLabels,ReduceListSpacing=false}

% *=======================================================*
% *.................Index sur une colonne.................*
\makeatletter
\renewenvironment{theindex}
{\if@twocolumn
  \@restonecolfalse
  \else
  \@restonecoltrue
  \fi
  \section*{\indexname}%
  \@mkboth{\MakeUppercase\indexname}%
  {\MakeUppercase\indexname}%
  \thispagestyle{plain}\parindent\z@
  \parskip\z@ \@plus .3\p@\relax
  \columnseprule \z@
  \columnsep 35\p@
  \let\item\@idxitem}
{\if@restonecol\onecolumn\else\clearpage\fi}
\makeatother
\newcommand*{\mainidx}[1]{\textbf{\hyperpage{#1}}}
% *=======================================================*

\newif\ifcompile
\newif\ifVcompile
\Vcompiletrue
\compiletrue
\newcounter{example}
\stepcounter{example}

% *=======================================================*
% *..........Définition de l'environnement vasy...........*
% *=======================================================*
\fvset{resetmargins=true,commandchars=~£`}
\makeatletter

\newsavebox{\image}
\def\vasy{\FV@Environment{BVerbatim}{vasy}}
\def\FVB@vasy#1{\def\tmp{#1}\FVB@VerbatimOut{./include/#1.asy}}%
\def\FVE@vasy{%
  \FVE@VerbatimOut%
  \ifcompile\immediate\write18{LC_CTYPE=fr_FR.latin-1 asy-tex.sh \tmp}\fi%
  \noindent\begin{shaded}
    \noindent\begin{tabularx}{\textwidth}{|X}
      \hspace*{0mm}\hfill\fcolorbox{white}{white}{\includegraphics{./include/\tmp.pdf}}\hfill\hspace*{0mm}\\\hline
      \vspace*{0mm}\BVerbatimInput[commandchars=~£`]{./include/\tmp.tex}
    \end{tabularx}
  \end{shaded}
  \compiletrue\stepcounter{example}%
}
\DefineVerbatimEnvironment{vasy}{vasy}{}

\def\bvasy{\FV@Environment{BVerbatim}{bvasy}}
\def\FVB@bvasy#1{\def\tmp{#1}\FVB@VerbatimOut{./include/#1.asy}}%
\def\FVE@bvasy{%
  \FVE@VerbatimOut%
  \ifcompile\immediate\write18{asy-tex.sh \tmp}\fi%
  \sbox{\image}{\includegraphics{./include/\tmp.pdf}}%
  \noindent\begin{shaded}
    \noindent\begin{tabular}{c|c}\fcolorbox{white}{white}{\parbox[c]{\wd\image}{\usebox{\image}}}&
      \begin{tabularx}{\textwidth}{X}
        \vspace*{0mm}\BVerbatimInput[commandchars=~£`]{./include/\tmp.tex}\\
      \end{tabularx}
    \end{tabular}
  \end{shaded}\compiletrue\stepcounter{example}%
}
\DefineVerbatimEnvironment{bvasy}{bvasy}{}

\def\aVerbatim{\FV@Environment{Verbatim}{aVerbatim}}
\def\FVB@aVerbatim{\FVB@VerbatimOut{./include/tmp_}}%
\def\FVE@aVerbatim{%
  \FVE@VerbatimOut%
  \noindent\begin{shaded}\noindent\VerbatimInput[frame=none]{./include/tmp_}\end{shaded}
}
\DefineVerbatimEnvironment{aVerbatim}{aVerbatim}{}

\newcounter{tmpfile}
\def\Vcolor{\FV@Environment{BVerbatim}{Vcolor}}
\def\FVB@Vcolor{\FVB@VerbatimOut{./include/vcolor\thetmpfile.asy}}%
\def\FVE@Vcolor{%
  \FVE@VerbatimOut%
  \ifVcompile\immediate\write18{asy-tex.sh -nog vcolor\thetmpfile}\fi%
    \colorbox{bg-color}{\BVerbatimInput[commandchars=~£`,baseline=t]{./include/vcolor\thetmpfile.tex}}%
  \stepcounter{tmpfile}%
  \par%
}
\DefineVerbatimEnvironment{Vcolor}{Vcolor}{}

\makeatother

\newcommand{\geo}{l'extension \emph{geometry.asy}\xspace}
\newcommand{\Geo}{L'extension \emph{geometry.asy}\xspace}
% \newcommand{\code}[1]{\colorbox{bg-color}{\Verb+{#1}+}}
\newcommand{\code}[1]{\Verb+{#1}+}
\newcommand{\param}[1]{\Verb+{#1}+}
\newcommand{\mparam}[1]{\mbox{\param{#1}}}
\newcommand{\asymptote}{\textsc{asymptote}\xspace}
\newcommand{\Asymptote}{\textsc{asymptote}}
\newcommand{\ssi}{si et seulement si\xspace}
\renewcommand{\vec}[1]{\overrightarrow{#1}}

\newenvironment{modif}{%
  \color{red}\bf
}{%
}

\newenvironment{ajout}{%
  \color{red}\bf
}{}

%%
%% TOC configuration.
%%

\setlength{\cftbeforesecskip}{0.1ex}
\setlength{\cftbeforesubsecskip}{0.1ex}
\renewcommand{\cftsecfont}{\normalfont}
\renewcommand{\cftsecpagefont}{\normalfont}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

%%
%% Configure titles.
%%

\titleformat{name=\section}{\normalfont\rmfamily\Large\bfseries\color{brick}}{\thesection.}{1em}{}
\titleformat{name=\section,numberless}{\normalfont\rmfamily\Large\bfseries\color{brick}}{}{0em}{}
\titleformat{name=\subsection}{\normalfont\rmfamily\Large\bfseries\color{brick}}{\thesubsection.}{1em}{}
\titleformat{name=\subsubsection}{\normalfont\rmfamily\large\bfseries\color{brick}}{\thesubsubsection.}{1em}{}

\makeindex

\begin{document}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\title{\texttt{geometry.asy}\footnotemark[1]\\
  Géométrie euclidienne avec \asymptote}
\author{Philippe \textsc{Ivaldi}}
\date{Version 1.0\\\today}
\maketitle
\hspace*{0mm}\hfill
\begin{center}
  \includegraphics{include/symmedian_intro.pdf}
\end{center}
\hfill\hspace*{0mm}
\footnotetext[1]{%
  \begin{minipage}[t]{0.77\textwidth}
    Copyright \copyright{} 2007 Philippe Ivaldi.

    \begin{quotation}
      \noindent Permission is granted to copy, distribute and/or modify this document
      under the terms of the \emph{GNU} Lesser General Public License (see the
      file LICENSE in the top-level source directory).
    \end{quotation}
  \end{minipage}}

\renewcommand{\thefootnote}{\arabic{footnote}}
\newpage
\begin{abstract}
  \noindent%
  Ce document décrit l'utilisation de \geo qui facilite la création de
  figures de géométrie plane euclidienne en définissant de nouveaux
  types et de nouvelles routines pour le logiciel
  \href{http://asymptote.sourceforge.net/}{\Asymptote}.\\
  Après avoir dressé la liste des nouveaux types accompagnés d'une
  brève description, nous les étudierons séparément et détaillerons les
  routines et opérateurs qui leurs sont associés.
  \begin{center}\bfseries
    Remerciements
  \end{center}
  Je remercie particulièrement les personnes suivantes:
  \begin{itemize}
  \item Olivier \textsc{Guibé} pour son aide précieuse dans les
    algorithmes de mathématiques algébriques, ses encouragements et
    son écoute toujours attentive;
  \item John \textsc{Bowman} et Andy \textsc{Hammerlindl} sans qui
    \asymptote n'existerait pas;
  \item \href{http://forum.mathematex.net/membre3.html}{MB} qui a
    testé l'extension pendant son développement ce qui a permis de
    corriger, d'améliorer et d'ajouter des fonctionnalités.
  \end{itemize}
\end{abstract}
\tableofcontents

\hyperdef{section}{intro}{\section{Introduction}}%
\subsection{Liste des types d'objets}
\Geo définit de nombreux types d'objets couramment utilisés en géométrie plane
Euclidienne;          ces         objets          peuvent         être
\href{http://www.tout-savoir.net/lexique/definition/3814/instancier/}{instanciés}
comme peut  l'être un réel, instancié  par le type  \code{real}, ou un
chemin, instancié par le type \code{path}.\\
Dans la suite de ce document il est important de distinguer l'objet de
son type.
Par exemple l'objet \og{}équation quadratique à deux variables\fg{} est du type
\code{bqe} (pour "Bivariate Quadratic Equation") et possède lui-même
un objet nommé \param{a} de type \code{real[]}; on y accède par \code{un\_objet\_bqe.a}.\\
Voici la liste exhaustive des types définis par \geo:
\begin{description}
\item[\index{coordsys}coordsys] instancie un repère Cartésien;
  ce type est décrit dans la section
  \href{#section.coordsys}{Système de coordonnées} et son
  utilisation est détaillée dans la section
  \href{#section.point}{Points et vecteurs};
\item[\index{point}point \textmd{et} \index{vector}vector] point et vecteur relatifs à un repère Cartésien.\\
  Ces types sont décrits dans la section
  \href{#section.point}{Points et vecteurs} dont la lecture peut
  être différée si l'on ne souhaite pas utiliser un autre repère que
  celui par défaut; dans ce cas, on peut considérer que les types
  \code{point} et \code{vector} sont identiques au type \code{pair};
\item[\index{mass}mass] point massique relatif à un repère Cartésien
  (cf. \href{#section.mass}{Points massiques});
\item[\index{line}line \textmd{et} \index{segment}segment] le type
  \code{line} instancie une droite ou une demi-droite ou un segment
  de droite. Le type \code{segment}, qui instancie un
  segment de droite, est un dérivé (un fils) du type \code{line}; son
  existence ne se justifie que pour la clarté du code.\\
  Ces types seront décrits dans la section
  \href{#section.line}{Droites, demi-droites et segments};
\item[\index{conic}conic] instancie n'importe quelle
  conique (cf. \href{#section.conic}{Coniques}).\\
  Pour plus de lisibilité et d'optimisation du code\footnote{la détermination
    d'une tangente à un cercle diffère de celle d'une hyperbole} les types dérivés
  \href{#subsection.circle}{circle},
  \href{#subsection.ellipse}{ellipse},
  \href{#subsection.parabola}{parabola},
  \href{#subsection.hyperbola}{hyperbola},
  \href{#subsubsection.bqe}{bqe} (pour "Bivariate Quadratic
  Equation") sont aussi définis.

  Il est ainsi conseillé de toujours utiliser le type de conique le
  plus restreint suivant l'usage qui doit en être fait; il est tout à
  fait possible par la suite de convertir une conique particulière
  en une conique quelconque comme le montre l'exemple suivant:
  \begin{aVerbatim}
    ellipse un_cercle=circle((point)(0,0), 3);
    ...
    conic une_conique=un_cercle;
    ...
  \end{aVerbatim}
\item[\index{arc}arc] instancie un arc d'ellipse (cf. \href{#section.arc}{Arcs});
\item[\index{abscissa}abscissa] instancie une abscisse sur
  une droite (au sens large) ou une conique (cf. \href{#section.abscisse}{Abscisses});
\item[\index{triangle}triangle] instancie un triangle (cf. \href{#section.triangle}{Triangles}).\\
  Les objets relatifs à un triangle, accessibles par
  \code{un\_triangle.objet}, sont de type
  \begin{description}
  \item[\index{side}side] instancie un côté du triangle (cf. \href{#subsection.side}{Côtés});
  \item[\index{vertex }vertex] instancie un sommet du sommet du
    triangle (cf. \href{#subsection.vertex}{Sommets}).
  \end{description}
\item[\index{trilinear}trilinear] instancie des coordonnées
  trilinéaires relatives à un triangle (cf. \href{#subsection.trilinear}{Coordonnées trilinéaires}).
\end{description}

\subsection{Fonctionnement interne}
Les calculs portant sur un objet instancié par un des types
définis par \geo  s'effectuent d'après la nature même de l'objet, non d'après sa
représentation graphique qui n'est finalement qu'un \code{path} ou un
\code{pair}.

Ainsi le code suivant, qui marque l'intersection de deux cercles
tangents, se compile en cinq fois moins de temps que le code
équivalant utilisant le type \code{path} à la place du type \code{circle}.
\compiletrue%
\begin{bvasy}{circle_loop}
  import geometry;
  size(3cm,0);
  circle cle1=circle((point)(0,0), 1);
  circle cle2=circle((point)(sqrt(2),sqrt(2)), 1);
  draw(cle1); draw(cle2);
  dot(intersectionpoints(cle1, cle2));
\end{bvasy}
\subsection{Index et exemples externes à ce document}
Un index et une galerie d'exemples de toutes les routines, types, et
opérateurs créés par \geo permettent une exploration détaillée de ce module:
\begin{itemize}
\item \href{http://piprim.tuxfamily.org/asymptote/geometry/modules/geometry.asy.index.sign.html}{index ordonné par nom de fonction};
\item \href{http://piprim.tuxfamily.org/asymptote/geometry/modules/geometry.asy.index.type.html}{index ordonné par type de fonction};
\item \href{http://piprim.tuxfamily.org/asymptote/geometry/index.html}{galerie d'exemples}.
\end{itemize}

\subsection{Conversion automatique des types (\og{}casting\fg{})}
Les objets de types précédemment énumérés peuvent être traités par des routines
qui leurs sont propres, celles définies par \geo, ou par des routines
natives d'\asymptote grâce à la conversion de type. Par exemple un cercle, de type
\code{circle}, peut être tracé directement avec la routine standard
\code{draw} grâce à la conversion automatisée \code{circle} vers \code{path} alors
que le code \code{dot(un\_cercle);} renverra un message d'erreur car
la routine \code{dot} attend un type \code{path} \textbf{exactement}; il faut
alors forcer la conversion de type en écrivant \code{dot((path)un\_cercle);}.

\hyperdef{section}{coordsys}{\section{\index{Système de coordonnées|mainidx}%
    \index{coordsys|mainidx}Systèmes de coordonnées}}
La lecture de cette section peut être différée si l'on ne souhaite pas
utiliser un autre repère du plan que celui par défaut. Dans ce cas
il suffit de savoir que \geo utilise le type \code{point} à la place
du type \code{pair} et que le type \code{vector} est équivalent au
type \code{pair}.

Les paragraphes suivants traitent des routines de base sur les
repères Cartésiens, l'utilisation effective des repères étant détaillée
dans la section \href{#section.point}{Points et vecteurs}.
\subsection{Le type coordsys}
\Geo permet de définir des objets dans un repère Cartésien du plan
quelconque; un tel repère est de type \code{coordsys}.
Comme le montre l'exemple suivant:
\begin{itemize}
\item  le repère par défaut est
  \index{coordsys!defaultcoordsys}\code{defaultcoordsys},
  c'est celui utilisé nativement par \asymptote;
\item le repère courant est \code{currentcoordsys} dont la
  valeur par défaut est\linebreak\code{defaultcoordsys}.
\end{itemize}
\compiletrue%
\begin{bvasy}{defaultcoord}
  import geometry;
  size(4cm,0);
  show(defaultcoordsys);
  show("$O'$", shift((1,1))*currentcoordsys);
\end{bvasy}

\subsection{Définir un système de coordonnées}
\index{coordsys!cartesiansystem}\index{coordsys!currentcoordsys}
Pour définir un repère on peut utiliser la commande
\code{cartesiansystem} ou appliquer une transformation à un repère existant
comme illustré dans l'exemple suivant:
\compiletrue%
\begin{bvasy}{cartesiancoord}
  import geometry;
  size(4cm,0);
  coordsys R=cartesiansystem((2,1), i=(1,1), j=(-1,1));

  show("$O'$","$\vec{u}$", "$\vec{v}$", R, xpen=invisible);
  show("$O''$","$\vec{u'}$", "$\vec{v'}$",
  rotate(90)*R, xpen=invisible);
  show(defaultcoordsys);
\end{bvasy}

\subsection{Changer un objet pair de repère}
\textbf{Les exemples de cette section sont donnés à titre indicatif}, le
moyen le plus efficace pour définir, modifier et convertir des coordonnées dans un repère étant
d'utiliser le type \code{point} (voir \href{#section.point}{Points
  et vecteurs}).

Les deux principales routines pour définir ou convertir des coordonnées, de
type \code{pair}, dans un repère sont en fait des opérateurs:
\begin{itemize}
\item \index{coordsys!*}
  \begin{Vcolor}
    pair operator *(coordsys R, pair m)
  \end{Vcolor}

  Permet de convertir les coordonnées de \param{m} données dans le
  repère \param{R} en coordonnées relatives au repère par
  défaut. Ainsi, dans l'exemple suivant, le point \param{M} a pour
  coordonnées $(0,5\,;\,0,5)$ dans \param{R} et $(2\,;\,2)$ dans \code{defaultcoordsys}:
  \compiletrue%
  \begin{bvasy}{deftorel}
    import geometry;
    size(4cm,0);
    coordsys R=cartesiansystem((2,1), i=(1,1), j=(-1,1));
    pair M=R*(0.5,0.5);
    dot("", M);
    show(R);
  \end{bvasy}
\item \index{coordsys!*}
  \begin{Vcolor}
    pair operator /( pair m, coordsys R)
  \end{Vcolor}
  Permet de convertir les coordonnées de \param{m} données dans le
  repère par défaut en coordonnées relatives au repère \param{R}. Ainsi, dans l'exemple
  suivant, les points \param{M}  et \param{P} ont les mêmes coordonnées
  dans \param{R} et \param{Rp} respectivement:
  \compiletrue%
  \begin{bvasy}{reltodef}
    import geometry;
    size(4cm,0);
    coordsys R=cartesiansystem((2,1), i=(1,1), j=(-1,1));
    coordsys Rp=cartesiansystem((-2,-1), i=(-1,1), j=(-1,-1));
    pair M=R*(1,1);
    dot("$M$", M);
    pair P=Rp*(M/R);
    dot("$P$", P);
    show(R, xpen=invisible);
    show("$O'$", "$\vec{u}$", "$\vec{v}$", Rp, xpen=invisible);
  \end{bvasy}
\end{itemize}

\subsection{Autres routines}
\begin{itemize}
\item \index{coordsys!*}
  \compiletrue%
  \begin{Vcolor}
    path operator *(coordsys R, path g)
  \end{Vcolor}
  Autorise le code du type \code{coordsys*path} qui
  renvoie la reconstruction du chemin \param{g} comme si chaque n\oe{}ud du
  chemin était donné dans le repère \param{R}.
\item \index{coordsys!*}
  \compiletrue%
  \begin{Vcolor}
    coordsys operator *(transform t, coordsys R)
  \end{Vcolor}
  Autorise le code \code{transform*coordsys}. Noter que
  \code{shiftless(t)} est appliqué à \param{R.i} et \param{R.j}.
\end{itemize}

\hyperdef{section}{point}{\section{\index{point|mainidx}Points et vecteurs}}
\subsection{Les points}
\subsubsection{Principes de base}
À la différence du type \code{pair} qui permet de
repérer un point dans le repère par défaut, le type \code{point}
permet de repérer un point dans n'importe quel repère Cartésien (voir
\href{#section.coordsys}{coordsys}); un objet de type
\code{point} fait toujours référence au repère dans lequel il est défini.

\index{point!casting}Grâce au \og{}casting\fg{}, un \code{point} peut être globalement assimilé à
un \code{pair} si l'on utilise seulement le repère par
défaut. Ainsi, dans l'exemple suivant, le \code{pair M} et le
\code{point P} marquent le même point:
\compiletrue%
\begin{bvasy}{point1}
  import geometry;
  size(4cm,0);
  show(currentcoordsys, xpen=invisible);
  pair M=(1,1); dot("$M$", M, W, linewidth(2mm));
  point P=(1,1); dot("$P$", P, red);
\end{bvasy}
\index{currentcoordsys}L'exemple suivant montre comment la modification du repère
courant influe sur le \og{}casting\fg{} \code{pair} vers \code{point}
dans le cas du point \param{A} et comment définir un point dans un repère spécifique grâce à la
routine \code{point point(coordsys R, pair m)}
\index{point(coordsys,pair,real)} dans le cas du point \param{B}.
\compiletrue%
\begin{vasy}{point2}
  import geometry;
  size(6cm,0);
  currentcoordsys=cartesiansystem((3,0), i=(1,1), j=(-1,1));
  show("$O_1$", "$\vec{u_1}$", "$\vec{v_1}$", currentcoordsys, xpen=invisible);
  point A=(1,1);
  dot("$A$", A);
  coordsys Rp=rotate(90)*currentcoordsys;
  show("$O_2$", "$\vec{u_2}$", "$\vec{v_2}$", Rp, xpen=invisible);
  point B=point(Rp, (1,1));
  dot("$B$", B);
\end{vasy}
L'utilisation de la routine \code{point locate(pair m);}\index{locate} permet aussi de
convertir directement, sans nommer de point, un \code{pair} en
\code{point}:
\compiletrue%
\begin{bvasy}{point3}
  import geometry;
  size(4cm,0);
  currentcoordsys=cartesiansystem((3,0), (1,0), (1,1));
  show("", currentcoordsys);
  point A=(1,1);
  dot("$A$", A); draw(locate(0)--A);
  draw(locate((0,1))--A, dashed); draw(locate((1,0))--A, dashed);
\end{bvasy}
L'exemple suivant montre comment convertir un type \code{pair} en type
\code{point} de telle sorte qu'ils représentent le même point et ainsi
obtenir ses coordonnées dans deux repères distincts.
\compiletrue%
\begin{bvasy}{point4}
  import geometry;
  size(4cm,0);
  coordsys R=cartesiansystem((2,3), i=(1,0), j=(0.5,1));
  show(currentcoordsys);
  show(Label("$O_1$",blue), Label("$\vec{u}$",blue),
  Label("$\vec{v}$",blue), R, xpen=invisible, ipen=blue);
  pair A=(3,1);
  dot("", A, red);
  point B=point(R, A/R);
  dot("", B, W, blue);
\end{bvasy}
La routine
\index{point!changecoordsys}\code{changecoordsys}
permet de changer facilement le repère d'un \code{point}:
\compiletrue%
\begin{vasy}{point5}
  import geometry;
  size(4cm,0);
  currentcoordsys=cartesiansystem((0,0), i=(1,0), j=(0.5,1));
  show(currentcoordsys);
  coordsys R=cartesiansystem((4,3), i=(-1,0), j=(-0.5,1));
  show(Label("$O_1$",blue), Label("$\vec{u}$",align=S,blue),
  Label("$\vec{v}$",align=E,blue), R, xpen=invisible, ipen=blue);
  point A=(3,1);
  dot("", A, red);
  point B=changecoordsys(R, A);
  dot("", B, W, blue);
\end{vasy}
\index{point!+}\index{point!-}\index{point!*}\index{point!/}
Comme pour le type \code{pair} les opérateurs \code{+}, \code{-},
\code{*}, \code{/} sont disponibles pour le type \code{point}. Il est à
noter toutefois qu'une opération effectuée avec deux
points définis relativement à des repères différents renvoie un
\code{point} défini dans le repère par défaut
\code{defaultcoordsys}; l'utilisateur est alors prévenu de cette
conversion automatique par un avertissement.

\index{coordsys!polar}\index{polar|see{coordsys polar}}
Pour repérer un point à l'aide de coordonnées polaires on peut
utiliser la méthode\linebreak\code{pair polar(real r, real angle)} d'un
objet de type \code{coordsys} comme le montre l'exemple suivant:
\compiletrue%
\begin{bvasy}{point6}
  import geometry;
  size(4cm,0);
  coordsys R=cartesiansystem((1,2), i=(1,0.5), j=(-1,1));
  show(R);

  for (int i=0; i < 360; i += 10) {
    pen p=(i/360)*red;
    dot(point(R, R.polar(1,radians(i))), p);
  }

  point A=point(R, R.polar(1,radians(40)));
  draw((string)abs(A), R.O--A);
\end{bvasy}

\subsubsection{Autres routines}
Maintenant que les routines de base concernant le type \code{point} sont
définies, passons en revue les autres routines le concernant:
\begin{itemize}
\item \index{origin(coordsys)}
  % \compiletrue
  \begin{Vcolor}
    point origin(coordsys R=currentcoordsys)
  \end{Vcolor}
  Retourne l'origine du repère \param{R} en tant que point.\\
  La constante \code{point origin}\index{origin} est l'origine du
  repère par défaut.
\item \index{point(coordsys,explicit point,real)}
  % \compiletrue
  \begin{Vcolor}
    point point(coordsys R, explicit point M, real m=M.m)
  \end{Vcolor}
  Retourne le point de masse \param{m} dont les coordonnées relatives à \param{R} ont les mêmes
  valeurs que celles de \param{M}.\\Ne pas confondre cette routine avec
  \code{changecoordsys}.

\item \index{coordinates(point)}
  % \compiletrue
  \begin{Vcolor}
    pair coordinates(point M)
  \end{Vcolor}
  Renvoie les coordonnées de \param{M} relatives à son repère.

\item \index{samecoordsys(bool...point[])}
  % \compiletrue
  \begin{Vcolor}
    bool samecoordsys(bool warn=true ... point[] M)
  \end{Vcolor}
  Renvoie \code{true} \ssi tous les points sont relatifs au même repère.\\
  Si \param{warm} vaut true et si les repères sont différents un
  avertissement est généré.
\item \index{standardizecoordsys(coordsys,bool...M)}
  % \compiletrue
  \begin{Vcolor}
    point[] standardizecoordsys(coordsys R=currentcoordsys,
    bool warn=true ... point[] M)
  \end{Vcolor}
  Renvoie les points, sous forme de tableau, relatifs au même repère \param{R}.\\
  Si \param{warm} vaut \code{true} et si les repères sont différents un
  avertissement est généré.
\item
  % \compiletrue
  \begin{Vcolor}
    pair[] operator cast(point[] P)
  \end{Vcolor}
  \og{}Casting\fg{} \code{point[]} vers \code{pair[]}.
\item \index{locate(point)}
  % \compiletrue
  \begin{Vcolor}
    pair locate(point P)
  \end{Vcolor}
  Renvoie les coordonnées de \param{P} dans le repère par défaut.
\item \index{*(transform,explicit point)}
  % \compiletrue
  \begin{Vcolor}
    point operator *(transform t, explicit point P)
  \end{Vcolor}
  Définit \code{transform*point}.\\
  Noter que les transformations \code{scale}, \code{xscale},
  \code{yscale} et \code{rotate} sont définies relativement au repère
  par défaut ce qui n'est en général pas souhaité quand le repère
  courant est modifié.\\
  Pour pallier cet inconvénient on peut utiliser les routines
  \code{scale(real,point)}, \code{xscale(real,point)}, \code{yscale(real,point)},
  \code{rotate(real,point)}, \code{scaleO(real)},
  \code{xscaleO(real)}, \code{yscaleO(real)} et \code{rotateO(real)}
  qui sont décrites dans la section \href{section.transform1}{Transformations (partie 1)}.
\item \index{*(explicit point,explicit pair)}
  % \compiletrue
  \begin{Vcolor}
    point operator *(explicit point P1, explicit pair p2)
  \end{Vcolor}
  Définit \code{point*pair}.\\
  \param{p2} est supposé représenter les coordonnées d'un point relativement au
  repère dans lequel \param{P1} est défini.
\item \index{==(explicit point,explicit point)}
  % \compiletrue
  \begin{Vcolor}
    bool operator ==(explicit point M, explicit point P)
  \end{Vcolor}
  Définit le test \code{M == N} qui renvoie \code{true} \ssi \code{MN < EPS}.
\item \index{!=(explicit point,explicit point)}
  % \compiletrue
  \begin{Vcolor}
    bool operator !=(explicit point M, explicit point N)
  \end{Vcolor}
  Définit le test \code{M != N} qui renvoie \code{true} \ssi \code{MN >= EPS}.
\item \index{abs(coordsys,pair)}
  % \compiletrue
  \begin{Vcolor}
    real abs(coordsys R, pair m)
  \end{Vcolor}
  Renvoie le module $\vert$\param{m}$\vert$ relativement au repère \param{R}.
\item \index{abs(explicit point)}
  % \compiletrue
  \begin{Vcolor}
    real abs(explicit point M)
  \end{Vcolor}
  Renvoie le module $\vert\mparam{M}\vert$ relativement au repère dans
  lequel \param{M} est défini.
\item \index{length(explicit point)}
  % \compiletrue
  \begin{Vcolor}
    real length(explicit point M)
  \end{Vcolor}
  Renvoie le module $\vert\mparam{M}\vert$ relativement au repère dans
  lequel \param{M} est défini.
\item \index{conj(explicit point)}
  % \compiletrue
  \begin{Vcolor}
    point conj(explicit point M)
  \end{Vcolor}
  Renvoie le conjugué de \param{M} relativement au repère dans lequel il est défini.
\item \index{degrees(explicit point,coordsys,bool)}
  % \compiletrue
  \begin{Vcolor}
    real degrees(explicit point M, coordsys,
    R=M.coordsys, bool warn=true)
  \end{Vcolor}
  Renvoie l'angle de \param{M} en degrés relativement au repère \param{R}.
\item \index{angle(explicit point,coordsys,bool)}
  % \compiletrue
  \begin{Vcolor}
    real angle(explicit point M, coordsys,
    R=M.coordsys, bool warn=true)
  \end{Vcolor}
  Renvoie l'angle de \param{M} en radians relativement au repère \param{R}.
\item \index{finite(explicit point)}
  % \compiletrue
  \begin{Vcolor}
    bool finite(explicit point p)
  \end{Vcolor}
  Même fonctionnement que \code{finite(pair m)} mais évite des calculs
  avec des coordonnées infinies.
\item \index{dot(point,point)}
  % \compiletrue
  \begin{Vcolor}
    real dot(point A, point B)
  \end{Vcolor}
  Renvoie le produit scalaire \param{A}{.}\param{B} relativement au
  repère dans lequel est défini \param{A}.
\item \index{real dot(point,explicit pair)}
  % \compiletrue
  \begin{Vcolor}
    real dot(point A, explicit pair B)
  \end{Vcolor}
  Renvoie le produit scalaire \param{A}{.}\param{B} après conversion des
  coordonnées de \param{A} dans le repère par défaut.
  \code{dot(explicit pair,point)} est aussi défini.

\end{itemize}

\hyperdef{section}{vector}{\subsection{\index{vector|mainidx}Les vecteurs}}
\subsubsection{Principes de base}
Dans l'exemple suivant les points \param{M} et \param{P} sont définis relativement à
des repères distincts. Le point \param{Q}, somme de \param{M} et \param{P}, s'obtient en
additionnant les coordonnées de \param{M} et de \param{P} \textbf{après leur conversion dans
  le repère par défaut}; ainsi $\vec{\mbox{\param{OQ}}}=\vec{\mbox{\param{OM}}}+\vec{\mbox{\param{OP}}}$.
% \compiletrue
\begin{bvasy}{somme_point}
  import geometry;
  size(4cm,0);
  show(currentcoordsys);
  coordsys R=cartesiansystem((2,2), i=(1,0.5), j=(-1,1));
  show("$O_1$", "$\vec{u}$", "$\vec{v}$", R, xpen=invisible);

  point M=(-1,1); dot("M", M);

  point P=point(R, (1,1)); dot("P", P);

  point Q=M+P; dot("Q=M+P", Q);
\end{bvasy}
En définissant le vecteur $\vec{\mbox{\param{w}}}$ par \code{vector w=vector(R, P.coordinates);}
ou, plus simplement, par \code{vector w=P;} on a $\vec{\mbox{\param{w}}}=\vec{\mbox{\param{O}}_{1}\mbox{\param{P}}}$ et le code
\code{point Q=M+w;} définit \param{Q} tel
que $\vec{\mbox{\param{OQ}}}=\vec{\mbox{\param{OM}}}+\vec{\mbox{\param{O}}_{1}\mbox{\param{P}}}$; ce qui est le résultat
souhaité. L'exemple suivant en est une illustration:
% \compiletrue
\begin{bvasy}{somme_point_vecteur}
  import geometry;
  size(4cm,0);
  show(currentcoordsys, xpen=invisible);
  coordsys R=cartesiansystem((2,2), i=(1,0.5), j=(-1,1));
  show("$O_1$", "$\vec{u}$", "$\vec{v}$", R, xpen=invisible);

  point M=(-1,1); dot("M", M);
  point P=point(R, (1,1)); dot("P", P);
  vector w=P; show("$\vec{w}$", w, linewidth(bp), Arrow(3mm));
  point Q=M+w; dot("Q=M+w", Q);
\end{bvasy}
Un objet \param{u} de type \code{vector} fonctionne comme un objet de type
\code{point} mais sa conversion en \code{pair} ou en \code{point} \param{M}
relatif au repère par défaut s'effectue de telle façon que
$\vec{\mparam{u}}=\vec{\mparam{OM}}$ comme le montre cette exemple qui utilise la
routine \index{locate(vector)}\code{pair locate(vector v)}:
% \compiletrue
\begin{bvasy}{locate_vector}
  import geometry; size(4cm,0);
  currentcoordsys=cartesiansystem((1.25,0.75), i=(1,1), j=(-1,1));
  coordsys Rp=currentcoordsys; coordsys R=defaultcoordsys;
  show(R);
  show("$O'$","$\vec{u}$","$\vec{v}$", Rp, xpen=invisible);
  point P=(0.75,0.5); dot("$P$",P); vector w=P;
  pen bpp=linewidth(bp);
  draw("$\vec{w}$", origin()--origin()+w, W, bpp, Arrow(3mm));
  draw("$\vec{w}$", origin--locate(w), E, bpp, Arrow(3mm));
\end{bvasy}
Les routines décrites pour le type \code{point} sont aussi disponibles
pour le type \code{vector}. Voici quelques exemple simples qui en
illustrent le comportement:
\compiletrue%
\begin{bvasy}{somme_vector}
  import geometry;
  size(4cm,0);
  pen bpp=linewidth(bp);
  currentcoordsys=cartesiansystem((0,0), i=(1,1), j=(-1,1));
  show(currentcoordsys, xpen=invisible);

  vector u=(0.5,1), v=rotate(-135)*u/2;
  show("$\vec{u}$", u, bpp, Arrow(3mm));
  show("$\vec{v}$", v, bpp, Arrow(3mm));
  show(Label("\vec{u}+\vec{v}",EndPoint), u+v, bpp, Arrow(3mm));
\end{bvasy}
\compiletrue%
\begin{vasy}{somme_vector2}
  import geometry;
  size(8cm,0);
  pen bpp=linewidth(bp);
  currentcoordsys=cartesiansystem((0,0), i=(1,1), j=(-1,1));
  show(currentcoordsys, xpen=invisible);

  vector u=(0.5,1), v=rotate(-135)*u/2;
  show("$\vec{u}$", u, bpp, Arrow(3mm));
  show("$\vec{v}$", v, bpp, Arrow(3mm));
  point P=(1,-1); dot("P", P, SW);
  draw(Label("\vec{u}",align=W), P--(P+u), bpp, Arrow(3mm));
  draw("$\vec{v}$", P--(P+v), bpp, Arrow(3mm));
  draw("$\vec{u}+\vec{v}$", P--(P+(u+v)), bpp, Arrow(3mm));
\end{vasy}
\subsubsection{\og{}Casting\fg{} vector/point}
Par le jeu du \og{}casting\fg{} un objet \code{point} peut être
converti en objet \code{vector} et réciproquement un objet
\code{vector} peut être converti en \code{point}. Au risque de se
répéter, il faut insister sur le fait que la distinction entre
\code{point} et \code{vector} existe seulement lorsque le repérage
s'effectue dans un autre repère que le repère par défaut.

Remarquer dans l'exemple suivant la différence entre \code{dot(w)} et
\code{dot(point(w))}; dans le deuxième cas le vecteur est converti en
point, celui \og{}pointé par le vecteur\fg{} alors que dans le premier
cas le vecteur est converti en \code{pair} comme expliqué
précédemment.\\
Noter enfin qu'il est possible d'écrire \code{point M=w;} au lieu de
\code{point M=point(w);}\index{point(explicit vector)}.
\compiletrue%
\begin{bvasy}{locate_vector2}
  import geometry; size(4cm,0);
  coordsys R=cartesiansystem((2,1), i=(1,1), j=(-0.75,1));
  show("$O_1$", "$\vec{u}$", "$\vec{v}$", R, xpen=invisible);
  show(currentcoordsys);

  vector w=vector(R, (1,1));
  show("$\vec{w}$", w, linewidth(bp), Arrow(3mm));
  dot("w", w, N); dot("point(w)", point(w), N);
\end{bvasy}
L'exemple suivant se passe donc de commentaires:
\compiletrue%
\begin{bvasy}{vector_point}
  import geometry; size(4cm,0); pen bpp=linewidth(bp);
  coordsys R=cartesiansystem((2,1), i=(1,1), j=(-0.75,1));
  show("$O_1$", "$\vec{u}$", "$\vec{v}$", R, xpen=invisible);
  show(currentcoordsys); vector w=vector(R, (1,1));
  show("$\vec{w}$", w, bpp, Arrow(3mm));
  show("$\vec{w}$", locate(w), bpp, Arrow(3mm));
  draw((1,2)--locate(w), green);
  draw((1,2)--point(w), blue);
\end{bvasy}
Le pendant de la routine \code{point point(explicit vector)} est
\code{vector vector(point)}\index{vector vector(point)}
\compiletrue%
\begin{bvasy}{point_vector}
  import geometry; size(4cm,0);
  coordsys R=cartesiansystem((2,1), i=(1,1), j=(-0.75,1));
  show("$O_1$", "$\vec{u}$", "$\vec{v}$", R, xpen=invisible);
  show(currentcoordsys);
  point M=point(R, (1,1)); dot("M", M, N);
  dot("vector(M)", vector(M), N);
  show(Label(scale(0.75)*"$\vec{O_1M}$", Relative(0.75)),
  M, linewidth(bp), Arrow(3mm));
\end{bvasy}
Enfin une attention particulière doit être portée sur les routines
\code{vector unit(point)}\index{unit(point)} et\linebreak
\code{vector unit(vector)}\index{unit(vector)} qui renvoient toujours
un objet \code{vector}. Ainsi, dans l'exemple suivant le comportement de
\code{point P=unit(B-A);} ne surprend pas alors que le comportement
de \code{dot(unit(B-A))} peut laisser dubitatif...
\compiletrue%
\begin{bvasy}{unit_vector}
  import geometry;
  size(4cm,0);
  coordsys R=cartesiansystem((2,1), i=(1,1), j=(-0.75,1));
  show("$O_1$", "$\vec{u}$", "$\vec{v}$", R, xpen=invisible);
  show(currentcoordsys, xpen=invisible);

  point A=point(R, (1,1)); dot("A", A); point B=point(R, (2,2));
  dot("B", B); point M=unit(B-A); dot("M", M);
  dot("unit(B-A)", unit(B-A), N);
  dot("A+unit(B-A)", A+unit(B-A), W);
\end{bvasy}
\subsubsection{Autres routines}
\index{collinear(vector,vector)}Comme déjà dit, toutes les
routines s'appliquant au type \code{point} s'appliquent aussi au type
\code{vector}. Mentionnons de plus la routine suivante dont le nom parle de lui-même:
\compiletrue%
\begin{Vcolor}
  bool collinear(vector u, vector v)
\end{Vcolor}

\hyperdef{section}{mass}{\section{\index{mass|mainidx}Points massiques}}
\hyperdef{subsection}{mass}{\subsection{Principes de base}}
Un objet de type \code{point} possède une masse à laquelle on peut
accéder par \code{un\_point.m} et une routine permet de calculer le
barycentre d'un ensemble de points.\\
\og{}Parfait!\fg{}\\
Non... pas tout à fait:
\begin{itemize}
\item si l'on définit un point \param{M} par
  \code{M=P1+P2;}, le point
  \param{M} hérite de la somme des masses de \param{P1} et \param{P2}, ce qui est une
  bonne chose, mais si le point \param{M} est défini par \code{M=P/2} les
  coordonnées de \param{M} sont égales à la moitié de celles de \param{P}, ce qui est
  attendu et entendu, mais la masse reste inchangée. Ainsi, pour
  définir un point dont la masse est la moitié de celle d'un autre point
  il \textbf{faudrait} écrire:
  % \compiletrue
  \begin{Vcolor}
    point P=point((1,1), 3);// point de masse 3

    point Q=P;
    Q.m=P.m/2;
  \end{Vcolor}
  ce qui peut rapidement devenir pénible;
\item faire apparaître la masse de façon homogène dans toutes les
  figures lors de l'utilisation des routines \code{dot} et
  \code{label} risque fort de devenir aussi rapidement pénible.
\end{itemize}
Essentiellement pour ces deux raisons, \geo définit un nouveau type,
le type \code{mass}\index{mass}, dont le comportement se rapproche au mieux de ce
que l'on peut attendre d'un \og{}point massique\fg{}. Par exemple
\code{mass M=objet\_mass/2} définit le point massique \param{M} avec les mêmes
coordonnées que \param{objet\_mass} mais d'un poids moitié, le code
\code{point M=objet\_mass/2} a le même comportement mais le résultat
est automatiquement converti en \code{point}.

Les routines \code{mass mass(explicit point)}\index{mass mass(explicit point)} et
\code{point point(explicit mass)}\index{point point(explicit mass)}
permettent de basculer facilement entre les deux types \code{mass} et
\code{point}; la division de la masse d'un objet de type \code{point}
peut alors se traiter de façon assez élégante:
\compiletrue%
\begin{Vcolor}
  point P=point((1,1), 3);// Point de masse 3

  point Q=mass(P)/2;// Division de la masse, les coordonnées sont inchangées

\end{Vcolor}
La division des coordonnées d'un objet de type \code{mass} se traite de même:
\begin{Vcolor}
  mass P=mass((1,1), 3);// Masse de poids 3

  mass Q=point(P)/2;// Division des coordonnées, le poids est inchangé

\end{Vcolor}
\subsection{Autres routines}
Grâce au \og{}casting\fg{} toutes les fonctionnalités du type \code{point} sont
disponibles pour le type \code{mass} avec les nuances qui ont été
mentionnées dans le paragraphe précédent. Voici la liste d'autres
routines en rapport avec les points massiques:
\begin{itemize}
\item \index{mass(coordsys,explicit pair,real)}
  \compiletrue%
  \begin{Vcolor}
    mass mass(coordsys R, explicit pair p, real m)
  \end{Vcolor}
  Renvoie un objet de type \code{mass} de poids \param{m} dont les coordonnées dans
  \param{R} sont \param{p}.
\item \index{mass(point,real)}
  \compiletrue%
  \begin{Vcolor}
    mass mass(point M, real m)
  \end{Vcolor}
  Convertit le point \param{M} en masse de poids \param{m}.
\item \index{point(explicit mass)|mainidx}
  \compiletrue%
  \begin{Vcolor}
    point(explicit mass m)
  \end{Vcolor}
  Convertit une masse de type \code{mass} en point, de type \code{point}.
\item \index{mass(explicit point)|mainidx}
  \compiletrue%
  \begin{Vcolor}
    mass mass(explicit point P)
  \end{Vcolor}
  Convertit un point, de type \code{point}, en une masse de type \code{mass}.
\item \index{masscenter(...mass[])}
  \compiletrue%
  \begin{Vcolor}
    mass masscenter(... mass[] M)
  \end{Vcolor}
  Barycentre des masses \param{M}. Noter que, grâce au \og{}casting\fg{}
  de \code{point[]} vers \code{mass[]}, cette routine fonctionne aussi
  avec comme paramètre un type \code{point[]}.
\item \index{defaultmassformat}
  \compiletrue%
  \begin{Vcolor}
    string defaultmassformat;
  \end{Vcolor}
  Format par défaut utilisé pour construire les labels des masses.\\
  Sa valeur par défaut est
  \code{"\$$\backslash$left(\%L;\%.4g$\backslash$right)\$"} dans
  laquelle \%L sera remplacé par le label de la masse. Un exemple est
  sûrement plus parlant:
  \compiletrue%
  \begin{bvasy}{defaultmassformat}
    import geometry;
    size(4cm,0);
    mass M=mass((0,0), 1); dot("M", M);

    defaultmassformat="$%L(%.4g)$";
    dot("M", M+(1,0));
  \end{bvasy}
  \vspace*{2mm}
\item \index{massformat(string,string,mass)}
  \compiletrue%
  \begin{Vcolor}
    string massformat(string format=defaultmassformat,
    string s, mass M)
  \end{Vcolor}
  Renvoie une chaîne formatée par la commande \code{format} avec comme
  paramètre \param{format}, dans laquelle \%L est remplacé par \param{s}, et le poids de \param{M}.
  \compiletrue%
  \begin{Vcolor}
    import geometry;

    write(massformat(s="foo", mass((0,0),1000)));
    // Renvoie $\left(foo;1000\right)$


    write(massformat("%L\_%e", "foo", mass((0,0),1000)));
    // Renvoie foo\_1\!\times\!10^{3\phantom{+}}

  \end{Vcolor}
  \vspace*{2mm}
\item \index{void label(picture,Label,mass,align,string,pen,filltype)}
  \compiletrue%
  \begin{Vcolor}
    void label(picture pic=currentpicture, Label L, mass M,
    align align=NoAlign, string format=defaultmassformat,
    pen p=nullpen, filltype filltype=NoFill)
  \end{Vcolor}
  Place en \param{M} le label renvoyé par \code{massformat(format,L,M)}.
\item \index{void label(picture,Label,mass,align,string,pen,filltype)}
  \compiletrue%
  \begin{Vcolor}
    void dot(picture pic=currentpicture, Label L, mass M, align align=NoAlign,
    string format=defaultmassformat, pen p=currentpen)
  \end{Vcolor}
  Place en \param{M} une marque de point et le label renvoyé par \code{massformat(format,L,M)}.
\end{itemize}
Pour terminer cette section voici trois exemples faisant intervenir
quelques routines précédemment décrites.
\compiletrue%
\begin{bvasy}{mass_ex1}
  import geometry;
  size(4cm,0);
  mass A=mass((1,0), 3);
  mass B=mass((0,1), sqrt(3));
  point C=(0.25,0); // C hérite d'un poids de 1 par défaut.

  dot("B", B, N); dot("C", C, S); dot("A", A, S);
  draw(A--B--C--cycle, linewidth(bp));
  dot("G", masscenter(A,B,mass(C)), 2NE);
\end{bvasy}
\compiletrue%
\begin{bvasy}{mass_ex2}
  import geometry;
  size(5cm,0);
  int n=50;
  mass[] M;
  real m, step=360/n;
  pair dir;
  for (int i=0; i < 2*n; ++i) {
    dir=dir(i*step);
    m=i+1;
    M.push(mass(m*dir, m));
    dot(locate(M[i]));
  }
  dot("G",masscenter(... M), red);
\end{bvasy}
\compiletrue%
L'exemple suivant montre comment l'on peut construire tous les barycentres partiels de \param{n} points,
chaque barycentre étant relié aux points du système dont il est issu:
\begin{vasy}{mass_ex3}
  import geometry;
  size(7cm,0);
  int[][] parties(int n) {
    int[][] oi;

    void loop(int[] arr, int i) {
      oi.push(arr);
      for (int j=i; j < arr.length; ++j) {
        int[] tt=copy(arr);
        tt[j]=1;
        loop(tt, j+1);}}
    loop(sequence(new int(int n){return 0;}, n), 0);
    return oi;}

  int n=6;
  real step=360/n;
  point[] M;

  for (int i=0; i < n; ++i) {
    M[i]=point(dir(i*step), 1);
    dot(M[i],linewidth(2mm));}

  int[][] part=parties(n); int l=part.length;
  point[][] group=new point[l][];

  for (int i=0; i < l; ++i)
  for (int j=0; j < n; ++j)
  if(part[i][j] == 1) group[i].push(M[j]);

  point[][] partbar=new point[l][2];

  for (int i=0; i < l; ++i) {
    if(group[i].length > 0) partbar[i][0]=masscenter(...group[i]);
    for (int j=0; j < group[i].length; ++j)
    draw(group[i][j]--partbar[i][0]);
    if(group[i].length > 0) dot(partbar[i][0], 0.8*red);}
\end{vasy}

\hyperdef{section}{transform1}{\section{\index{transformation|mainidx}Transformations affines
    (partie 1)}}
En plus des transformations affines natives \geo définit d'autres
transformations. Certaines de ces transformations ont un comportement spécifique suivant le
repère courant utilisé. Ainsi, afin de ne pas imposer au lecteur
ne travaillant que dans le repère par défaut la description des
routines spécifiques aux repères, cette section est divisée en deux sous-sections.
\subsection{Transformations indépendantes du repère courant}
\begin{itemize}
\item \index{scale(real,point)}
  % \compiletrue
  \begin{Vcolor}
    transform scale(real k, point M)
  \end{Vcolor}
  Homothétie de centre M et de rapport k.
  \begin{bvasy}{scale}
    import geometry;
    size(7.5cm,0);
    pen bpp=linewidth(bp); real k=sqrt(2);

    point A=(0,0); dot("A", A, SW);
    point B=(1,2); dot("B", B, N);
    point M=(-1,1);
    dot("M", M, -dir(M--A,M--B));

    point Ap=scale(k, M)*A;
    dot("A'", Ap, SW, red);
    point Bp=scale(k, M)*B;
    dot("B'", Bp, N, red);

    draw(M--Ap, grey); draw(M--Bp, grey);
    draw(A--B, bpp);
    draw(rotate(unit(Bp-Ap))*"$k\times AB$",
    Ap--Bp, bpp+red);
  \end{bvasy}
  % \compiletrue
  \begin{bvasy}{scale2}
    import geometry;
    size(7.5cm,0);
    pen bpp=linewidth(bp);
    point A=(0,0); dot("A", A, SW);
    point B=(1,2); dot("B", B, NW);
    point C=(-1,1); dot("C", C,N);
    path g=A--B--C--cycle; draw(g, bpp);
    point M=(0,1);
    path gp=scale(2, M)*g; draw(gp, bpp);
    for (int i=0; i < 3; ++i) draw(M--point(gp,i));
    dot("A'", point(gp,0), SW);
    dot("B'", point(gp,1), NW);
    dot("C'", point(gp,2), N);
  \end{bvasy}
\item \index{projection(point,point)}
  % \compiletrue
  \begin{Vcolor}
    transform projection(point A, point B)
  \end{Vcolor}
  Projection orthogonale sur la droite \param{(AB)}.
  \begin{bvasy}{projectionAB}
    import geometry;
    size(6cm);
    point A=(2,2); point B=(4,1); point M=(4,3);
    path cle=shift(3,2.5)*scale(.25)*unitcircle;
    draw(cle, linewidth(bp));

    transform proj=projection(A,B);
    point Mp=proj*M;

    draw(proj*cle, 1mm+red);
    dot("A", A, unit(A-B)); dot("B", B, unit(B-A));
    dot("M", M, unit(M-Mp));
    dot("M'", Mp, unit(Mp-M), red);
    draw(M--Mp, grey); draw(A--B);
    markrightangle(M,Mp,A, grey);
  \end{bvasy}
\item \index{projection(point,point,point,point,bool)}
  % \compiletrue
  \begin{Vcolor}
    transform projection(point A, point B, point C, point D, bool safe=false)
  \end{Vcolor}
  Projection sur la droite \param{(AB)} parallèlement à \param{(CD)}.\\
  Si \param{safe} vaut \code{true} et \param{(AB)} est parallèle
  à \param{(CD)}, l'identité est renvoyée.\\
  Si \param{safe} vaut \code{false} et \param{(AB)} est parallèle à \param{(CD)}, l'homothétie de
  centre \param{O} et de rapport infini est renvoyée.\\
  \begin{bvasy}{projectionABCD}
    import geometry;
    size(6cm);
    point A=(2,2); point B=(4,1); point C=(3.75,3);
    point D=(3.5,4); point M=(2.5,3.5);
    path cle=shift(2.5,3)*scale(0.25)*unitcircle;
    draw(cle, linewidth(bp)); draw(line(C,D), grey);

    transform proj=projection(A,B,C,D);
    point Mp=proj*M;

    draw(proj*cle, 1mm+red);
    dot("A", A, unit(A-B)); dot("B", B, unit(B-A));
    dot("C", C); dot("D", D); dot("M", M, unit(M-Mp));
    dot("M'", Mp, 2*unit(Mp-M), red);
    draw(M--Mp, grey); draw(A--B);
  \end{bvasy}
\item \index{scale(real,point,point,point,point,bool)}
  % \compiletrue
  \begin{Vcolor}
    transform scale(real k, point A, point B, point C, point D, bool safe=false)
  \end{Vcolor}
  Affinité de rapport \param{k}, d'axe \param{(AB)} et de direction \param{(CD)}.
  Si \param{safe} vaut \code{true} et \param{(AB)} est parallèle à \param{(CD)}, l'identité est renvoyée.\\
  Si \param{safe} vaut \code{false} et \param{(AB)} est parallèle à \param{(CD)}, l'homothétie de
  centre \param{O} et de rapport infini est renvoyée.\\
  \begin{bvasy}{scaleABCD}
    import geometry;
    size(6cm,0);
    pen bpp=linewidth(bp); real k=sqrt(2);
    point A=(0,0), B=(2,0), C=(3.5,1);
    point D=(4,2), M=(6,3);
    path cle=shift(1,2)*unitcircle;
    draw(cle, bpp);
    draw(line(A,B));
    draw(line(C,D), grey);

    transform dilate=scale(k,A,B,C,D);
    draw(dilate*cle, bpp+red);
    point Mp=dilate*M;

    point P=intersectionpoint(line(A,B), line(M,Mp));
    draw(line(P,M), grey);
    dot("A", A, S); dot("B", B, S); dot("C", C);
    dot("D", D); dot("M", M, W); dot("P", P, NW);
    dot("M'", Mp, W, red);
    distance("$k\times PM$", P, Mp, 6mm, grey,
    joinpen=grey+dashed);
  \end{bvasy}
\end{itemize}
\subsection{Transformations dépendantes du repère courant}
\begin{itemize}
\item \index{xscale(real,point)}
  % \compiletrue
  \begin{Vcolor}
    transform xscale(real k, point M)
  \end{Vcolor}
  \hypertarget{xscale(real,point)}{Affinité} de rapport \param{k}, d'axe \og{}l'axe passant par \param{M} et parallèle à
  \param{(Oy)}\fg{} et de direction \param{(Ox)}.
  \begin{bvasy}{xscale1}
    import geometry;
    size(6cm,0);
    real k=sqrt(2);
    point A=(1,2); dot("A", A, S);
    point M=(-1,1); dot("M", M, W);

    point Ap=xscale(k, M)*A; dot("A'", Ap, red);
    label("A'=xscale(k,M)*A", (0.75,1.125), red);

    point P=extension(A, Ap, M, M+N);
    dot("P", P, W); draw(M--P); draw(P--Ap);
    perpendicularmark(P, dir(-45));
    distance("$k\times PA$", P, Ap, -3mm, grey);
  \end{bvasy}
  Le même exemple dans un repère quelconque:
  \index{xscale(real,point)}
  % \compiletrue
  \begin{vasy}{xscale2}
    import geometry;
    size(6cm,0);
    currentcoordsys=cartesiansystem((2,1), i=(1,0.5), j=(-0.75,1));
    show(currentcoordsys, ipen=blue, jpen=red, xpen=invisible);

    real k=sqrt(2);
    point A=(2,1.25);
    point M=(-0.75,0.25); dot("M", M, W);

    point Ap=xscale(k, M)*A;
    dot("A'", Ap, red); dot("A", A, I*unit(A-Ap));

    point P=intersectionpoint(line(A,Ap), line(M,M+N));
    dot("P", P, W); draw(M--P, red); draw(P--Ap, blue);
    distance("$k\times PA$", P, Ap, -3mm, grey);
  \end{vasy}
\item \index{yscale(real,point)}
  % \compiletrue
  \begin{Vcolor}
    transform yscale(real k, point M)
  \end{Vcolor}
  \hypertarget{yscale(real,point)}{Affinité} de rapport k, d'axe \og{}l'axe passant par M et parallèle à
  (Ox)\fg{} et de direction (Oy).
  \begin{bvasy}{yscale1}
    import geometry;
    size(6cm,0);
    real k=sqrt(2);
    point A=(2,1);
    point M=(-1,-1); dot("M", M, W);

    point Ap=yscale(k, M)*A;
    dot("A'", Ap, red); dot("A", A, I*unit(A-Ap));
    label("A'=yscale(k,M)*A", (0,1), red);

    point P=intersectionpoint(line(A,Ap), line(M,M+E));
    dot("P", P); draw(M--P); draw(P--Ap);
    perpendicularmark(P, dir(135));
    distance("$k\times PA$",P,Ap,-12mm,grey,grey+dashed);
  \end{bvasy}
  Le même exemple dans un repère quelconque:
  \index{yscale(real,point)}
  % \compiletrue
  \begin{vasy}{yscale2}
    import geometry;
    size(6cm,0);
    currentcoordsys=cartesiansystem((2,1), i=(1,0.5), j=(-0.75,1));
    show(currentcoordsys, ipen=blue, jpen=red, xpen=invisible);

    real k=sqrt(2);
    point A=(2,1);
    point M=(-2,-1); dot("M", M, W);

    point Ap=yscale(k, M)*A;
    dot("A'", Ap, -I*unit(A-Ap), red); dot("A", A, -I*unit(A-Ap));
    point P=intersectionpoint(line(A,Ap), line(M,M+E));
    dot("P", P, locate(unit(A-Ap))); draw(M--P, blue); draw(P--Ap, red);
    distance("$k\times PA$", P, Ap, 3mm, grey);
  \end{vasy}
\item \index{scaleO(real)}
  % \compiletrue
  \begin{Vcolor}
    transform scaleO(real x)
  \end{Vcolor}
  Homothétie de rapport x et de centre \og{}l'origine du repère
  courant\fg{}. Cette transformation est identique à
  \code{scale(x, origin())}.\\
  Dans l'exemple suivant, on notera la différence entre
  \code{scale(k)*P} et \code{scaleO(k)*P}.
  % \compiletrue
  \begin{bvasy}{scaleO}
    import geometry; size(4.5cm,0);
    currentcoordsys=cartesiansystem((2,1), i=(1,0.5), j=(-1,1));
    show("$O_1$", "$\vec{u}$", "$\vec{v}$", currentcoordsys,
    xpen=invisible); show(defaultcoordsys, xpen=invisible);

    real k=sqrt(2); point P=(1,1); dot("P", P);

    point P1=scale(k)*P, P2=scaleO(k)*P; dot("scale(k)*P", P1, N);
    dot("scaleO(k)*P", P2, W); draw((0,0)--locate(P1));
    draw(origin()--P2);
  \end{bvasy}
\item \index{xscaleO(real)}
  % \compiletrue
  \begin{Vcolor}
    transform xscaleO(real x)
  \end{Vcolor}
  Identique à \code{xscale(x, origin())} (voir \href{#xscale(real,point)}{xscale(real,point)}).
\item \index{yscaleO(real)}
  % \compiletrue
  \begin{Vcolor}
    transform yscaleO(real x)
  \end{Vcolor}
  Identique à \code{yscale(x, origin())} (voir \href{#yscale(real,point)}{yscale(real,point)}).
\item \index{rotateO(real)}
  % \compiletrue
  \begin{Vcolor}
    transform rotateO(real angle)
  \end{Vcolor}
  Identique à \code{rotate(angle, origin())}.
\end{itemize}

% \compiletrue
\hyperdef{section}{line}{\section{\index{droite|mainidx}Droites, demi-droites et segments}}
\subsection{Le type \texorpdfstring{\og{}line\fg{}}{line}}
Un objet de type \code{line} représente une droite, une demi-droite ou
un segment de droite suivant la valeur de ses propriétés
\code{bool extendA,extendB;} accessible via \code{line.extendA} et
\code{line.extendB}.
La description complète des méthodes et
propriétés du type \code{line} est accessible
\href{http://piprim.tuxfamily.org/asymptote/geometry/modules/geometry.asy.index.sign.html#struct\%20line}{ici}.

\subsubsection{Droites définies par deux points, routines de base}
\begin{itemize}
\item \index{line(point,bool,point,bool)}%
  % \compiletrue
  \begin{Vcolor}
    line line(point A, bool extendA=true, point B, bool extendB=true)
  \end{Vcolor}
  Définit un objet de type \code{line} passant par les deux points
  \param{A} et \param{B}, orientée de \param{A} vers
  \param{B}. Si \param{extendA} vaut \code{true} la \og{}droite\fg{}
  s'étend du côté de \param{A}.\\
  Un objet de type \code{line} appartient au repère dans lequel sont
  définis les deux points \param{A} et \param{B} mais si ces
  deux points sont définis dans des repères
  distincts, ils sont automatiquement redéfinis relativement au repère
  par défaut et un message d'avertissement est généré.
\item \index{Ox()}\index{Oy()}\index{Ox}\index{Oy}%
  % \compiletrue
  \begin{Vcolor}
    line Ox(coordsys R=currentcoordsys)
  \end{Vcolor}
  Renvoie l'axe des abscisses du repère \param{R}.\\
  La routine
  \code{line Oy(coordsys R=currentcoordsys)} est aussi
  définie.\\
  Les constantes \code{Ox} et \code{Oy} sont les axes du repère par défaut.
\item \index{draw(picture,Label,line,bool,bool,align,pen,arrowbar,Label,marker)}%
  % \compiletrue
  \begin{Vcolor}
    void draw(picture pic=currentpicture, Label L="",
    line l, bool dirA=l.extendA, bool dirB=l.extendB,
    align align=NoAlign, pen p=currentpen,
    arrowbar arrow=None, Label legend="", marker marker=nomarker)
  \end{Vcolor}
  Trace dans \param{pic} la \og{}droite\fg{} \param{l} sans altérer
  la taille de l'image si le label est correctement positionné et la
  variable \code{linemargin} positive.\\
  Les paramètres booléens \param{dirA} et \param{dirB} contrôlent la
  section infinie à afficher.\\
  Noter qu'il est possible de contrôler la marge
  entre le bord de l'image et la trace des droites en modifiant la
  variable réelle \code{linemargin} dont la valeur par défaut est 0;
  dans le cas où cette marge est négative, la taille de l'image sera
  modifiée.
  \compiletrue%
  \begin{bvasy}{line_base}
    import geometry;
    size(6cm,0);
    linemargin=2mm;
    point A=(0,0), B=(2, 0), C=(3,1), D=(1,1);
    dot("A", A, NW); dot("B", B, SE); dot("C", C);
    dot("D", D, W);

    line AB=line(A, B);
    line CB=line(C, false, B);
    line CD=line(C, false, D, false);
    line AD=line(A, false, D);

    draw("(AB)", AB); draw("[CB)", CB);
    draw(Label("[CD]",Relative(0.5),align=N), CD);
    draw("[AD)", AD); draw(box((-1,-2),(4,3)));
  \end{bvasy}
\item \index{show(picture,line,pen)}%
  \compiletrue%
  \begin{Vcolor}
    void show(picture pic=currentpicture, line l, pen p=red)
  \end{Vcolor}
  Affiche dans \param{pic} les points qui ont servi à définir la
  droite \param{l} ainsi que le vecteur directeur et le vecteur
  normal.
\item \index{intersectionpoint(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    point intersectionpoint(line l1, line l2)
  \end{Vcolor}
  Renvoie le point d'intersection des objets \param{l1}
  et \param{l2}.\\
  S'il n'y a aucun point d'intersection ou s'il y en a une infinité,
  c'est le point de coordonnée\linebreak\code{(infinity,infinity)} qui est
  renvoyé.\\
  Noter que si les deux droites sont définies relativement à des
  repères différents, le point d'intersection est défini relativement
  au repère pas défaut \code{defaultcoordsys} et un
  avertissement est généré.\\
  L'exemple suivant est une illustration du célèbre théorème de
  {\sc Pascal} qui affirme que \og{}Les points de concours des côtés
  opposés de tout hexagone inscrit dans un cercle sont alignés.\fg{}
  % \compiletrue
  \begin{bvasy}{th_pascal}
    import geometry;
    size(6.5cm,0);
    draw(unitcircle, grey);
    point[] P;
    real[] a=new real[]{0, 20, 60, 90, 240, 280};
    real cor=24.0036303043338;
    for (int i=0; i < 6; ++i) {
      P.push((Cos(a[i]-cor),Sin(a[i]-cor)));
    }
    pen[] p=new pen[] {0.8*blue, 0.8*yellow, 0.8*green};
    line[] l;
    for (int i=0; i < 6; ++i) {
      l.push(line(P[i],P[(i+1)%6]));
      draw(l[i], p[i%3]);
      draw(P[i]--P[(i+1)%6], linewidth(bp));
    }
    point[] inter;
    for (int i=0; i < 3; ++i) {
      inter.push(intersectionpoint(l[i],l[(i+3)%6]));
      dot(inter[i], 1.5*dotsize()+0.8*red);
    }
    draw(line(inter[0],inter[1]), bp+0.8*red);
    draw(box((-1,-2.722), (2.229,2.905)), invisible);
  \end{bvasy}
\item \index{intersectionpoints(line l, path g)}%
  \compiletrue%
  \begin{Vcolor}
    point[] intersectionpoints(line l, path g)
  \end{Vcolor}
  Renvoie, sous forme de tableau, les points d'intersections de la
  \og{}droite\fg{} \param{l} avec le chemin \param{g}.
\end{itemize}

\subsubsection{Droites définies par équations}
\begin{itemize}
\item \index{line(coordsys,real,real,real)}%
  \compiletrue%
  \begin{Vcolor}
    line line(coordsys R=currentcoordsys, real a, real b, real c)
  \end{Vcolor}
  Renvoie la droite d'équation $\mparam{a}x+\mparam{b}y+\mparam{c}=0$
  dans le repère \param{R}.
\item \index{line(coordsys,real,real)}%
  \compiletrue%
  \begin{Vcolor}
    line line(coordsys R=currentcoordsys, real slope, real origin)
  \end{Vcolor}
  Renvoie la droite de pente \param{slope} et d'ordonnée à
  l'origine \param{origin} donnés relativement au repère \param{R}.
\end{itemize}
\subsubsection{Droites et parallélisme}
\begin{itemize}
\item \index{parallel(point,line)}%
  \compiletrue%
  \begin{Vcolor}
    line parallel(point M, line l)
  \end{Vcolor}
  Renvoie la droite parallèle à \param{l} passant par \param{M}.
\item \index{parallel(point,explicit vector)}%
  \compiletrue%
  \begin{Vcolor}
    line parallel(point M, explicit vector dir)
  \end{Vcolor}
  Renvoie la droite de vecteur directeur \param{dir} et passant par \param{M}.
\item \index{parallel(point,explicit pair)}%
  \compiletrue%
  \begin{Vcolor}
    line parallel(point M, explicit pair dir)
  \end{Vcolor}
  Renvoie la droite de vecteur directeur \param{dir} donné dans le
  repère courant \code{currentcoordsys} et passant par \param{M}.
\item \index{parallel(line,line,bool)}%
  \compiletrue%
  \begin{Vcolor}
    bool parallel(line l1, line l2, bool strictly=false)
  \end{Vcolor}
  Renvoie \code{true} si \param{l1} et \param{l2} sont parallèles
  (strictement si \param{stricly} vaut \code{true}).
\end{itemize}
\compiletrue%
\begin{bvasy}{parallel}
  import geometry;
  size(5cm,0);
  coordsys R=cartesiansystem((1,-2), i=(1,1), j=(-1,1));
  show("$O$","$\vec{u}$","$\vec{v}$", R, ypen=invisible);

  pen bpp=linewidth(bp);
  point A=(0,0), B=(2, 0.5), C=(3,2);
  vector w=vector(R, (1.5,2)); line AB=line(A,B);

  dot("A", A, NW); dot("B", B, NE); dot("C", C, N);
  show("$\vec{w}$", w, bpp+0.8*red, Arrow(3mm));
  draw(AB, bpp+0.8*blue);
  draw(parallel(C, AB), bpp+0.8*blue);
  draw(parallel(B, w), bpp+0.8*red);
  draw(parallel(A, R.i), bpp);
  draw(box((-1,-3),(4,3)), invisible);
\end{bvasy}
\subsubsection{Droites et angles}
\begin{itemize}
\item \index{line(real,point)}\index{line(point,real)}%
  \compiletrue%
  \begin{Vcolor}
    line line(real a, point A=point(currentcoordsys,(0,0)))
  \end{Vcolor}
  Renvoie la droite passant par \param{A} et faisant un
  angle de \param{a} degrés avec l'axe des abscisses du repère dans
  lequel est défini \param{A}.\\
  La routine \code{line(point,real)} est aussi définie.
  \begin{bvasy}{line_angle1}
    import geometry;
    size(5cm,0);
    coordsys R=cartesiansystem((1,-2), i=(1,0.5), j=(-1,1));
    show("$O_{1}$", "$\vec{u}$", Label("$\vec{v}$", align=E),
    R, ipen=blue, ypen=invisible);
    show(defaultcoordsys, ypen=invisible);
    point A=point(R,(1,1)); dot("A", A, NW);

    line l=line(A, 30);
    draw(l, bp+blue);
    markangle("$30^\circ$", Ox(R), l, grey);

    A=changecoordsys(defaultcoordsys, A);
    line ll=line(A, 40);
    draw(ll, bp+red);
    markangle("$40^\circ$", Ox, ll, grey);
    draw(box((-0.6,-2.8), (2,-0.3)), invisible);
  \end{bvasy}
\item \index{bisector(line,line,real,bool)}%
  \compiletrue%
  \begin{Vcolor}
    line bisector(line l1, line l2, real angle=0, bool sharp=true)
  \end{Vcolor}
  Renvoie l'image de la bissectrice de l'angle formé par les droites
  orientées \param{l1} et \param{l2} par la rotation de centre
  \og{}l'intersection de \param{l1} et \param{l2}\fg{} et
  d'angle \param{angle}.\\
  Si le paramètre \param{sharp} vaut \code{true}, cette routine
  renvoie la bissectrice de l'angle aigu.\\
  Noter que la droite renvoyée hérite du repère dans lequel est
  \hypertarget{bisectorline}{défini} \param{l1}.
%  \compiletrue%
  \begin{bvasy}{bisector_line}
    import geometry;
    size(5cm,0);
    point A=(0,0), B=(2*Cos(40),2*Sin(40)); line l1=line(A,B);
    draw(l1, linewidth(bp));
    line l2=rotate(100,A)*l1;
    draw(l2, linewidth(bp));
    line bis=bisector(l1,l2); draw(bis, bp+blue);
    line Bis=bisector(l1,l2,false); draw(Bis, bp+0.8*red);
    markangleradiusfactor *= 4;
    marker mark2=StickIntervalMarker(2, 1, red, true);
    markangle(2, l1, l2, red, mark2);
    markangle(2, reverse(l2), reverse(l1), radius=-markangleradius(),
    red, mark2);
    markangleradiusfactor *= 3/2;
    marker mark1=StickIntervalMarker(2, 2, blue, true);
    markangle(2, l1, reverse(l2), radius=-markangleradius(),
    blue, mark1);
    markangle(2, reverse(l1), l2, radius=-markangleradius(),
    blue, mark1);
    draw(box((-1,-1),(1,1)), invisible);
  \end{bvasy}
\item \index{sector(int,int,line,line,real,bool)}%
  \compiletrue%
  \begin{Vcolor}
    line sector(int n=2, int p=1, line l1, line l2, real angle=0, bool sharp=true)
  \end{Vcolor}
  Renvoie l'image de la p-iéme droite qui partage l'angle formé par les droites
  orientées \param{l1} et \param{l2} en \param{n} parties égales par la
  rotation de centre \og{}l'intersection de \param{l1}
  et \param{l2}\fg{} et d'angle \param{angle}.\\
  Si le paramètre \param{sharp} vaut \code{true}, cette routine
  considère l'angle aigu.\\
  Noter que la droite renvoyée hérite du repère dans lequel est
  défini \param{l1}. Ci-après, un exemple d'utilisation pour partager
  des angles en trois parties d'égales mesures.
  \compiletrue%
  \begin{vasy}{sector_line}
    import geometry;
    size(10cm,0);
    point A=(0,0), B=(3,0), C=(0.795,1.5);
    dot(A); dot(B); dot(C);
    pen pb=0.8*blue, pr=0.8*red, py=0.8*yellow, bpp=linewidth(bp);
    line AB=line(A,B), AC=line(A,C), BC=line(B,C);
    draw(AB, bpp); draw(AC, bpp); draw(BC, bpp);

    line bA1=sector(3,AB,AC), bA2=sector(3,2,AB,AC);
    line bB1=sector(3,AB,BC), bB2=sector(3,2,AB,BC);
    line bC1=sector(3,AC,BC), bC2=sector(3,2,AC,BC);
    draw(bA1, bpp+pb); draw(bA2, bpp+pb);
    draw(bB1, bpp+pr); draw(bB2, bpp+pr);
    draw(bC1, bpp+py); draw(bC2, bpp+py);

    markangleradiusfactor *= 8;
    markangle(BC, reverse(AB), pr, StickIntervalMarker(3,1,pr,true));
    markangleradiusfactor /= 3;
    markangle(reverse(AC), reverse(BC), py, StickIntervalMarker(3,2,py,true));
    markangleradiusfactor *= 3/2;
    markangle(AB, AC, pb, StickIntervalMarker(3,3,pb,true));
  \end{vasy}
\item \index{perpendicular(point,line)}%
  \compiletrue%
  \begin{Vcolor}
    line perpendicular(point M, line l)
  \end{Vcolor}
  Renvoie la droite perpendiculaire à \param{l} passant par \param{M}.
\item \index{line perpendicular(point,explicit vector)}%
  \compiletrue%
  \begin{Vcolor}
    line perpendicular(point M, explicit vector normal)
  \end{Vcolor}
  Renvoie la droite passant par \param{M} et de vecteur normal \param{normal}.
\item \index{perpendicular(point,explicit pair)}%
  \compiletrue%
  \begin{Vcolor}
    line perpendicular(point M, explicit pair normal)
  \end{Vcolor}
  Renvoie la droite passant par \param{M} et de vecteur
  normal \param{normal} donné dans le repère courant\linebreak\code{currentcoordsys}.
  \compiletrue%
  \begin{bvasy}{perpendicular}
    import geometry;
    size(5cm,0);
    pen bpp=linewidth(bp);
    coordsys R=cartesiansystem((0.5,-2), i=(1,1), j=(-1,1));
    show("$O$","$\vec{u}$","$\vec{v}$", R, xpen=bpp,
    ypen=invisible);
    point A=(0,1), B=(2,2);
    vector w=vector(R, (2,2)); line AB=line(A,B);
    dot("A", A, 2*dir(165)); dot("B", B, N);
    show(Label("$\vec{w}$",Relative(0.75)), w, bp+0.8*red,
    Arrow(3mm));
    draw(AB, bp+0.8*blue);
    draw(perpendicular(B, AB), bp+0.8*blue);
    draw(perpendicular(B, w), bp+0.8*red);
    draw(perpendicular(A, R.i), bpp);
    draw(box((-1,-3),(4,3)), invisible);
  \end{bvasy}
\item \index{angle(line,coordsys)}%
  \compiletrue%
  \begin{Vcolor}
    real angle(line l, coordsys R=coordsys(l))
  \end{Vcolor}
  Renvoie la mesure de l'angle, en radians dans $]-\pi\,;\,\pi]$, par rapport au
  repère \param{R} de la droite orientée que représente \param{l}.
\item \index{degrees(line,coordsys)}%
  \compiletrue%
  \begin{Vcolor}
    real degrees(line l, coordsys R=coordsys(l))
  \end{Vcolor}
  Renvoie la mesure de l'angle, en degrés dans $[0\,;\,360[$, par rapport au
  repère \param{R} de la droite orientée que représente \param{l}.
\item \index{sharpangle(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    real sharpangle(line l1, line l2)
  \end{Vcolor}
  Renvoie la mesure de l'angle aigu orienté, en radians dans
  $]-\frac{\pi}{2}\,;\,\frac{\pi}{2}]$, formé par \param{l1} et \param{l2}.
\item \index{sharpdegrees(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    real sharpdegrees(line l1, line l2)
  \end{Vcolor}
  Renvoie la mesure de l'angle aigu orienté, en degrés dans
  $]-90\,;\,90]$, formé par \param{l1} et \param{l2}.
\item \index{angle(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    real angle(line l1, line l2)
  \end{Vcolor}
  Renvoie la mesure de l'angle orienté, en radians dans
  $]-\pi\,;\,\pi]$, formé par les droites orientées représentées par \param{l1} et \param{l2}.
\item \index{degrees(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    real degrees(line l1, line l2)
  \end{Vcolor}
  Renvoie la mesure de l'angle orienté, en degrés dans
  $]-180\,;\,180]$, formé par les droites orientées représentées par \param{l1} et \param{l2}.
\end{itemize}
\subsubsection{Droites et opérateurs}
\begin{itemize}
\item \index{*(transform,line)}%
  \compiletrue%
  \begin{Vcolor}
    line operator *(transform t, line l)
  \end{Vcolor}
  Autorise le code \code{transform*line}.
\item \index{/(line,real)}\index{*(real,line)}%
  \compiletrue%
  \begin{Vcolor}
    line operator /(line l, real x)
  \end{Vcolor}
  Autorise le code \code{line/real}.\\
  Renvoie la \og{}droite\fg{} passant par \param{l.A/x}
  et \param{l.B/x}.\\
  \code{line operator *(real x, line l)} est aussi défini.
\item \index{*(point,line)}%
  \compiletrue%
  \begin{Vcolor}
    line operator *(point M, line l)
  \end{Vcolor}
  Autorise le code \code{point*line}.\\
  Renvoie la \og{}droite\fg{} passant pas \code{unit(M)*l.A} et \code{unit(M)*l.B}.
\item \index{+(line,vector)}\index{-(line,vector)}%
  \compiletrue%
  \begin{Vcolor}
    line operator +(line l, vector u)
  \end{Vcolor}
  Autorise le code \code{line+vector}.\\
  Renvoie l'image de \param{l} par la translation de
  vecteur \param{u}.\\
  \code{line operator -(line l, vector u)} est aussi défini.
\item \index{^^(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    line[] operator ^^(line l1, line l2)
  \end{Vcolor}
  Autorise le code \code{line\circonflexe\circonflexe{}line}.\\
  Renvoie le tableau \code{new line[] {l1,l2}}.
\item \index{==(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    bool operator ==(line l1, line l2)
  \end{Vcolor}
  Autorise le test \code{line == line}.\\
  Renvoie \code{true} \ssi \param{l1} et \param{l2} représente la même droite.
\item \index{!=(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    bool operator !=(line l1, line l2)
  \end{Vcolor}
  Autorise le test \code{line != line}.\\
  Renvoie \code{false} \ssi \param{l1} et \param{l2} représente la même droite.
\item \index{@(point,line)}%
  \compiletrue%
  \begin{Vcolor}
    bool operator @(point m, line l)
  \end{Vcolor}
  Autorise le code \code{point @ line}.\\
  Renvoie \code{true} \ssi le point \param{M} appartient à l'objet \param{l}.
\end{itemize}

\subsubsection{Autres routines}
Aux routines décrites dans cette section s'ajoutent des routines
pour récupérer l'\href{#section.abscissa}{abscisse} d'un point
appartenant à un objet de type \code{line}.
\begin{itemize}
\item \index{draw(picture,Label[],line[],align,pen[],arrowbar,Label,marker)}%
  \compiletrue%
  \begin{Vcolor}
    void draw(picture pic=currentpicture,Label[] L=new Label[], line[] l,
    align align=NoAlign, pen[] p=new pen[],
    arrowbar arrow=None,
    Label[] legend=new Label[], marker marker=nomarker)
  \end{Vcolor}
  Dessine chacune des droites représentées par \param{line[] l} avec
  le stylo correspondant \param{pen[] p}.\\
  Si \param{p} n'est pas spécifié le stylo courant est utilisé.
\item \index{draw(picture,Label[],line[],align,pen,arrowbar,Label,marker)}%
  \compiletrue%
  \begin{Vcolor}
    void draw(picture pic=currentpicture,Label[] L=new Label[], line[] l,
    align align=NoAlign, pen p,
    arrowbar arrow=None,
    Label[] legend=new Label[], marker marker=nomarker)
  \end{Vcolor}
  Dessine chacune des droites représentées par \param{line[] l} avec
  le même stylo \param{p}.\\
\item \index{distance(point,line)}\index{distance(line,point)}%
  \compiletrue%
  \begin{Vcolor}
    real distance(point M, line l)
  \end{Vcolor}
  Renvoie la distance de \param{M} à \param{l}.\\
  \code{real distance(line l,point M)} est aussi défini.
\item \index{sameside(point,point,line)}%
  \compiletrue%
  \begin{Vcolor}
    bool sameside(point M, point P, line l)
  \end{Vcolor}
  Renvoie \code{true} \ssi \param{M} et \param{P} sont du même côté
  de \param{l}.
\item \index{sameside(point,line,line)}%
  \compiletrue%
  \begin{Vcolor}
    point[] sameside(point M, line l1, line l2)
  \end{Vcolor}
  Renvoie un tableau composé de deux points: le premier est le projeté
  de \param{M} sur \param{l1} parallèlement à \param{l2} et le second est
  le projeté de \param{M} sur \param{l2} parallèlement à \param{l1}.
\item \index{coordsys(line)}%
  \compiletrue%
  \begin{Vcolor}
    coordsys coordsys(line l)
  \end{Vcolor}
  Renvoie le repère dans lequel est défini \param{l}.
\item \index{changecoordsys(coordsys,line)}%
  \compiletrue%
  \begin{Vcolor}
    line changecoordsys(coordsys R, line l)
  \end{Vcolor}
  Renvoie la \og{}droite\fg{} représentée par \param{l} relativement au
  repère \param{R}.
\item \index{reverse(line)}%
  \compiletrue%
  \begin{Vcolor}
    line reverse(line l)
  \end{Vcolor}
  Renvoie la droite représentée par \param{l} avec une orientation
  contraire à celle de \param{l}.
\item \index{extend(line l)}%
  \compiletrue%
  \begin{Vcolor}
    line extend(line l)
  \end{Vcolor}
  Renvoie la droite portée par \param{l} qui, rappelons le, peut
  être une demi-droite ou un segment de droite.
\item \index{complementary(explicit line)}%
  \compiletrue%
  \begin{Vcolor}
    line complementary(explicit line l)
  \end{Vcolor}
  Renvoie la demi-droite complémentaire de \param{l}; cette routine ne
  fonctionne que si \param{l} représente effectivement une demi-droite.
\item \index{concurrent(...line[])}%
  \compiletrue%
  \begin{Vcolor}
    bool concurrent(... line[] l)
  \end{Vcolor}
  Renvoie \code{true} \ssi les droites représentées par
  \code{line[] l} sont concourantes.
\item \index{perpendicular(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    bool perpendicular(line l1, line l2)
  \end{Vcolor}
  Renvoie \code{true} \ssi les droites représentées par
  \param{l1} et \param{l2} sont perpendiculaires.
\item \index{perpendicular(line,line)}%
  \compiletrue%
  \begin{Vcolor}
    bool perpendicular(line l1, line l2)
  \end{Vcolor}
\end{itemize}
\begin{itemize}%% !!!!!! REMPLACER cet itemize par le précédent !!!!!!!!%%
\item \index{point(line l,real)}%
  \compiletrue%
  \begin{Vcolor}
    point point(line l, real x)
  \end{Vcolor}
  Retourne le point entre \param{l.A} et \param{l.B} comme le
  ferait \code{point(l.A${-}{-}$l.B,x)}.
\item \index{relpoint(line,real)}%
  \compiletrue%
  \begin{Vcolor}
    point relpoint(line l, real x)
  \end{Vcolor}
  Retourne le point d'abscisse relative \param{x} donnée par rapport au
  segment $[\mparam{AB}]$. Autrement dit \param{relpoint(l,x)} renvoie \code{l.A+x*vector(l.B-l.A)}.
  \begin{bvasy}{relpoint_line}
    import geometry;
    size(0,6cm);

    point A=(0,0), B=(0,2);
    line l=line(A,B); show(l);

    dot("relpoint(l,0.75)", relpoint(l,0.75));
    dot("relpoint(l,-0.75)", relpoint(l,-0.75));
    dot("relpoint(l,1.5)", relpoint(l,1.5));
    dot("relpoint(l,-1.5)", relpoint(l,-1.5));

    addMargins(bmargin=5mm);
  \end{bvasy}
\item \index{curpoint(line,real)}%
  \compiletrue%
  \begin{Vcolor}
    point curpoint(line l, real x)
  \end{Vcolor}
  Retourne le point d'abscisse \param{x} donnée par rapport au
  repère $(\mparam{l.A}\,;\,\vec{\mparam{l.u}})$. Autrement dit \param{curpoint(l,x)} renvoie \code{l.A+x*unit(l.B-l.A)}.
  \begin{bvasy}{curpoint_line}
    import geometry;
    size(0,6cm);

    point A=(0,0), B=(0,2);
    line l=line(A,B); show(l);

    dot("curpoint(l,0.75)", curpoint(l,0.75));
    dot("curpoint(l,-0.75)", curpoint(l,-0.75));
    dot("curpoint(l,1.5)", curpoint(l,1.5));
    dot("curpoint(l,-1.5)", curpoint(l,-1.5));

    addMargins(bmargin=5mm);
  \end{bvasy}
\end{itemize}

\subsubsection{Droites et marqueurs}
\begin{itemize}
\item \index{markangle(picture,Label,int,real,real,line,line,arrowbar,pen,margin,marker)}%
  \compiletrue%
  \begin{Vcolor}
    void markangle(picture pic=currentpicture,
    Label L="", int n=1, real radius=0, real space=0,
    line l1, line l2,
    arrowbar arrow=None, pen p=currentpen,
    margin margin=NoMargin, marker marker=nomarker)
  \end{Vcolor}
  Marque par \param{n} arcs de cercle l'angle orienté formé par les
  \og{}droites\fg{} \param{l1} et \param{l2}. Les arcs sont dessinés
  dans le sens trigonométrique si \param{radius} est positif ou nul,
  dans le sens horaire sinon.\\
  Se reporter à \og{}\href{#bisectorline}{cette figure}\fg{} pour un exemple.
\item \index{perpendicularmark(picture,line,line,real,pen,int,margin,filltype)}%
  \compiletrue%
  \begin{Vcolor}
    void perpendicularmark(picture pic=currentpicture, line l1, line l2,
    real size=0, pen p=currentpen, int quarter=1,
    margin margin=NoMargin, filltype filltype=NoFill)
  \end{Vcolor}
  Marque un angle droit au point d'intersection de \param{l1}
  et \param{l2} dans le \param{quarter}ième quart de plan compté dans
  le sens trigonométrique, le premier étant celui formé par les
  vecteurs \param{l1.u} et \param{l2.u}.
  \begin{bvasy}{perpendicularmark_line}
    import geometry;
    size(5cm,0);
    transform t=rotate(135);
    line l1=t*line((0,0),E); line l2=t*line((0,0),N);

    perpfactor *=5.5;
    perpendicularmark(l1,l2, Fill(0.8*green));
    perpendicularmark(l1,l2, quarter=2, Fill(0.8*blue));
    perpendicularmark(l1,l2, quarter=3, Fill(0.8*red));
    perpendicularmark(l1,l2, quarter=4, Fill(0.8*yellow));

    pen bpp=linewidth(bp); position pos=Relative(0.75);
    show(Label("$u_1$",pos), l1.u, bpp, Arrow(3mm));
    show(Label("$u_2$",pos,align=SE), l2.u, bpp, Arrow(3mm));
    show("", -l1.u, invisible); show("", -l2.u, invisible);
  \end{bvasy}
\end{itemize}

\subsection{Le type \texorpdfstring{\og{}segment\fg{}}{segment}}
Comme déjà mentionné dans l'\href{#section.intro}{introduction}, le type \code{segment}, qui
instancie un segment de droite, est un dérivé (un fils) du type
\code{line}. Par le jeu du \og{}casting\fg{}, pratiquement toutes
les routines applicables à un objet de type \code{line} s'appliquent
aussi à un objet de type \code{segment} et réciproquement.

Il est cependant important de noter que, lors du tracé d'un segment, la
valeur de la variable \code{addpenline} est ajoutée au stylo
utilisé. Par défaut cette variable a pour valeur \param{squarecap},
afin d'avoir les extrémités droites, ce qui rend l'affichage d'un
segment en pointillé inefficient.\\
Pour contourner ce problème il y a trois solutions:
\begin{enumerate}
\item écrire \code{draw(un\_segment, roundcap+dotted);} au lieux de
  \code{draw(un\_segment, dotted);};
\item affecter la valeur \code{nullpen} à \code{addpenline}.
\item contacter l'auteur de \geo pour lui faire connaître
  son désaccord quant à la valeur par défaut de \code{addpenline};
\end{enumerate}

Enfin, tout comme les types \code{point} et \code{mass} sont
interchangeables, les objets de types \code{line} et \code{segment}
peuvent être converti de l'un vers l'autre en écrivant par exemple
\code{segment s=un\_obj\_line;}\linebreak ou \code{draw(segment(un\_obj\_line));} ou
encore \code{draw(line(un\_obj\_segment));}
comme le montre l'exemple suivant:
% \compiletrue
\begin{bvasy}{line_segment}
  import geometry;
  size(6cm,0);
  point A=SW, B=NE;
  label("$A$", A, NW); label("$B$", B, SE);

  line l=line(A,B);
  draw(l, bp+red);

  segment s=l;
  draw(s, linewidth(3bp));
  draw(line(rotate(90,midpoint(s))*s));
  draw(box(2*A,2*B), invisible);
\end{bvasy}
En dehors des routines définies pour les objets de type \code{line}
voici d'autres routines spécifiques aux objets de type \code{segment}:
\begin{itemize}
\item \index{segment(point,point)}%
  % \compiletrue
  \begin{Vcolor}
    segment segment(point A, point B)
  \end{Vcolor}
  Renvoie le segment de droite d'extrémités \param{A} et \param{B}.
\item \index{midpoint(segment)}%
  % \compiletrue
  \begin{Vcolor}
    point midpoint(segment s)
  \end{Vcolor}
  Renvoie le milieu du segment \param{s}.
\item \index{bisector(segment)}%
  % \compiletrue
  \begin{Vcolor}
    line bisector(segment s, real angle=0)
  \end{Vcolor}
  Renvoie l'image de la médiatrice de \param{s} par la rotation de
  centre \og{}le milieu de \param{s}\fg{} et d'angle \param{angle}.
\item \index{complementary(explicit segment)}%
  % \compiletrue
  \begin{Vcolor}
    line[] complementary(explicit segment s)
  \end{Vcolor}
  Renvoie sous forme de tableau les deux demi-droites de
  support \param{s} et d'extrémités respectives \param{s.A} et \param{s.B}.
\end{itemize}

\hyperdef{section}{transform2}{\section{\index{transformation|mainidx}Transformations
    affines (partie 2)}}
Certaines transformations décrites dans le section \href{#section.transform1}{Transformations
  affines (partie 1)}, définies à partir de points, peuvent aussi
être définies à partir de droites.
\begin{itemize}
\item \index{reflect(line)}
  % \compiletrue
  \begin{Vcolor}
    transform reflect(line l)
  \end{Vcolor}
  Renvoie la réflexion par rapport à \param{l}.
  \begin{bvasy}{reflect}
    import geometry;
    size(5cm,0);
    point A=origin, B=NE, M=2*B+N;
    dot("A", A, I*unit(A-B)); dot("B", B, I*unit(A-B));

    line AB=line(A,B);
    draw(AB, linewidth(bp));
    transform reflect=reflect(AB);

    point Mp=reflect*M;
    dot("M",M, unit(M-Mp)); dot("M'", Mp, unit(Mp-M), red);
    draw(segment(M,Mp), grey, StickIntervalMarker(2,2,grey));
  \end{bvasy}
\item \index{reflect(line,line,bool)}
  % \compiletrue
  \begin{Vcolor}
    transform reflect(line l1, line l2, bool safe=false)
  \end{Vcolor}
  Renvoie la réflexion par rapport à \param{l1} parallèlement à \param{l2}.\\
  Si \param{safe} vaut \code{true} et \param{l1} parallèle
  à \param{l2}, la routine renvoie l'identité.
  % \compiletrue
  \begin{bvasy}{reflect_dir}
    import geometry;
    size(5cm,0);
    line AB=line(origin, NE), CD=line(2*NE+N, 2*NE+SE);
    draw(AB, linewidth(bp)); draw(CD, linewidth(bp));
    transform reflect=reflect(AB,CD);

    point M=1.75*NE+0.5N, Mp=reflect*M;
    dot("M",M, unit(M-Mp)); dot("M'", Mp, unit(Mp-M), red);
    draw(segment(M,Mp), grey, StickIntervalMarker(2,2,grey));
    draw(box((1,1), (2.2,2.2)), invisible);
  \end{bvasy}
\item \index{scale(real,line,line,bool)}
  % \compiletrue
  \begin{Vcolor}
    transform scale(real k, line l1, line l2, bool safe=false)
  \end{Vcolor}
  Renvoie l'affinité de rapport k, d'axe \param{l1} et de direction \param{l2}.\\
  Si \param{safe} vaut \code{true} et \param{l1} parallèle
  à \param{l2}, la routine renvoie l'identité.
  % \compiletrue
  \begin{bvasy}{affinite_line}
    import geometry;
    size(6.5cm,0);
    pen bpp=linewidth(bp);
    line AB=line(origin, E), CD=line(2*NE+N, 2*NE+SE);
    draw(AB, bpp); draw(CD, bpp);

    transform dilatation=scale(1.5,AB,CD);

    path cle=shift(NE)*unitcircle;
    draw(cle,bpp);

    draw(dilatation*cle, 0.8*red+bpp);
    draw(inverse(dilatation)*cle, 0.8*blue+bpp);
    draw(box((-0.5,-0.5), (2.75,3)), invisible);
  \end{bvasy}
\item \index{projection(line)}
  % \compiletrue
  \begin{Vcolor}
    transform projection(line l)
  \end{Vcolor}
  Renvoie la projection orthogonale sur \param{l}.
\item \index{projection(line)}
  % \compiletrue
  \begin{Vcolor}
    transform projection(line l1, line l2, bool safe=false)
  \end{Vcolor}
  Renvoie la projection sur \param{l1} parallèlement à \param{l2}.\\
  Si \param{safe} vaut \code{true} et \param{l1} parallèle
  à \param{l2}, la routine renvoie l'identité.
\item \index{vprojection(line,bool)}
  % \compiletrue
  \begin{Vcolor}
    transform vprojection(line l, bool safe=false)
  \end{Vcolor}
  Renvoie la projection sur \param{l} parallèlement à la verticale.
  Cette routine est équivalente à \code{projection(l,line(origin,point(defaultcoordsys,S)),safe)}.\\
  Si \param{safe} vaut \code{true} et \param{l} est une droite
  verticale, la routine renvoie l'identité.
\item \index{hprojection(line,bool)}
  % \compiletrue
  \begin{Vcolor}
    transform hprojection(line l, bool safe=false)
  \end{Vcolor}
  Renvoie la projection sur \param{l} parallèlement à l'horizontale.
  Cette routine est équivalente à \code{projection(l,line(origin,point(defaultcoordsys,E)),safe)}.\\
  Si \param{safe} vaut \code{true} et \param{l} est une droite
  horizontale, la routine renvoie l'identité.
  % \compiletrue
  \begin{bvasy}{projection_line}
    import geometry;
    size(7.5cm,0); dotfactor*=1.5;
    currentcoordsys=rotate(20)*defaultcoordsys;
    show(currentcoordsys, xpen=invisible, ypen=red);

    point A=(-1,-3), B=(5,2);
    line l1=line(A,B); draw(l1, linewidth(bp));
    dot("$A$", A, SE); dot("$B$", B, NW);
    point M=(3,-3); dot("$M$", M);

    point P=projection(l1)*M;
    dot("$P$", P, 2W); draw(M--P);
    markrightangle(l1.A, P, M);

    point Q=vprojection(l1)*M;
    dot("$Q$", Q, 2W); draw(M--Q);

    point R=hprojection(l1)*M;
    dot("$R$", R, 2W); draw(M--R);

    point S=projection(l1,line((0,0),(0,1)))*M;
    dot("$S$", S, 2W); draw(M--S, red);
    draw(box((-1,-4),(5,5)), invisible);
  \end{bvasy}
\end{itemize}

% \compiletrue
\hyperdef{section}{conic}{\section{\index{conique|mainidx}Coniques}}
\subsection{Le type \texorpdfstring{\og{}conic\fg{}}{«conic»}}
\subsubsection{Description}
\Geo définit le type \code{conic} pour instancier une conique
quelconque non dégénérée. S'il est tout à fait possible
d'utiliser une instance de ce type, son existence est
plutôt destinée au fonctionnement interne de l'extension; on préférera
utiliser directement les types dérivés \code{circle}, \code{ellipse},
\code{parabola} et \code{hyperbola} décrits ultérieurement.

Attardons nous cependant un peu sur sa structure afin d'en définir
précisément les composantes:
\compiletrue%
\begin{center}
  \begin{Vcolor}
    struct conic { real e, p, h; point F; line D; }
  \end{Vcolor}
\end{center}
\begin{itemize}
\item \param{e} est l'excentricité;
\item \param{F} est un foyer et \param{D} la directrice associée;
\item \param{h} est la distance de \param{F} à \param{D};
\item \param{p} est le paramètre, il vérifie l'égalité \param{p=he}.
\end{itemize}

Les deux principales routines pour définir une conique quelconque sont:

\begin{enumerate}
\item \index{conic conic(point,l,real)}
  \compiletrue%
  \begin{Vcolor}
    conic conic(point F, line l, real e)
  \end{Vcolor}
  Retourne la conique de foyer \param{F} associé à la
  directrice \param{l} et d'excentricité \param{e}; en voici un exemple d'utilisation:
  \compiletrue%
  \begin{bvasy}{conic_base}
    import geometry;
    size(8cm,0);
    point F=(0,0); dot("F", F);
    line l=line((1,0),(1,1));
    draw(l);
    pen[] p=new pen[] {black,red,blue,green};
    for (int i=0; i < 4; ++i) {
      conic co=conic(F,l,0.5*i);
      draw(co, bp+0.8*p[i]);
    }
    draw(box((-1,-1.25), (3.5,1.25)), invisible);
  \end{bvasy}
\item \index{conic(point,point,point,point,point)}
  \begin{Vcolor}
    conic conic(point M1, point M2, point M3, point M4, point M5)
  \end{Vcolor}
  Retourne la conique non dégénérée passant par les
  points \param{M1}, \param{M2}, \param{M3}, \param{M4} et \param{M5}.
  \begin{vasy}{conic_5_points}
    import geometry;
    size(18cm,0);
    point B=(1.75,3), C=(-1,2), D=(-1.5,-0.5), F=(1.5,-1);

    for (int i=0; i < 360; i += 21) {
      point A=shift(D)*dir(i);
      dot(A,red);
      conic co=conic(A,B,C,D,F);
      draw(co, co.e < 1 ? black : 0.8*blue);
    }
  \end{vasy}
\end{enumerate}
On notera qu'il est aussi possible de définir une conique d'après son équation dans
un repère spécifique, voir la section \href{#subsection.bqe}{Équations
  de coniques}, et que d'autres façons de définir une conique sont
implémentées par des routines renvoyant un type spécifique de conique
qu'il est ensuite possible de convertir en type \code{conic}; voir
\href{#subsubsection.castingconic}{Coniques et \og{}casting\fg{}}.

\subsubsection{Routines de base}
Les routines suivantes peuvent être utilisées en remplaçant un objet
de type \code{conic} par l'un des types \code{circle}, \code{ellipse},
\code{parabola} ou \code{hyperbola} sauf lorsque le mot clef
\code{explicit} précède le type \code{conic} dans la définition de la
routine.

On notera qu'en plus des routines décrites dans cette section
s'ajoutent des routines retournant une \href{#section.abscissa}{abscisse}
d'un point sur un objet de type \code{conic}.
\begin{itemize}
\item \index{changecoordsys(coordsys,conic)}
  % \compiletrue
  \begin{Vcolor}
    conic changecoordsys(coordsys R, conic co)
  \end{Vcolor}
  Retourne la même conique que \param{co} relativement au repère \param{R}.
\item \index{coordsys(conic)}
  % \compiletrue
  \begin{Vcolor}
    coordsys coordsys(conic co)
  \end{Vcolor}
  Retourne le repère dans lequel est définie la conique \param{co}.
\item \index{canonicalcartesiansystem(explicit conic)}
  % \compiletrue
  \begin{Vcolor}
    coordsys canonicalcartesiansystem(explicit conic co)
  \end{Vcolor}
  \index{canonicalcartesiansystem(parabola)}
  \index{canonicalcartesiansystem(ellipse)}
  \index{canonicalcartesiansystem(hyperbola)}
  Retourne le repère canonique de la conique \param{co}.\\
  Les routines \code{canonicalcartesiansystem(ellipse)},
  \code{canonicalcartesiansystem(parabola)} et\linebreak
  \code{canonicalcartesiansystem(hyperbola)} sont aussi disponibles.\\
  L'exemple suivant en est une illustration dans le cas d'une ellipse.
  \begin{bvasy}{canoniccoord}
    import geometry;
    size(4cm,0);

    show(defaultcoordsys);
    ellipse el=ellipse((point)(2,4),3,2,45);
    dot("$F_1$", el.F1, dir(-45));
    dot("$F_2$", el.F2, dir(-45));
    draw(el, linewidth(bp), Arrow(3mm));
    show("$C$", "$\vec{u}$" ,"$\vec{v}$",
    canonicalcartesiansystem(el));
  \end{bvasy}

\item \index{conicnodesnumber(conic,real,real)}
  % \compiletrue
  \begin{Vcolor}
    int conicnodesnumber(conic co, real angle1, real angle2, bool dir=CCW)
  \end{Vcolor}
  Retourne le nombre de n\oe{}uds utilisés pour convertir la
  conique \param{co} en \code{path} entre les angles \param{angle1}
  et \param{angle2} donnés dans le sens de parcours \param{dir}.
\item \index{intersectionpoints(conic,conic)}
  % \compiletrue
  \begin{Vcolor}
    point[] intersectionpoints(conic co1, conic co2)
  \end{Vcolor}
  Retourne, sous forme d'un tableau, les points d'intersections des
  deux coniques \param{co1} et \param{co2}.
  % \compiletrue
  \begin{vasy}{inter_conic}
    import geometry; size(10cm); conic co[];
    co[0]=conic((-4.58,1.25), line((-5.45545,1.25), (-5.45545,2.12287)), 0.9165);
    draw(co[0]);
    co[1]=conic((0,-1),line((0,-3.5),(-1,-3.5)),1); draw(co[1]);
    co[2]=conic((-1.2,0), line((-5/6,0),(-5/6,-1)),1.2); draw(co[2]);
    dotfactor *= 2;
    for (int i=0; i < 3; ++i)
    for (int j=i+1; j < 3; ++j)
    dot(intersectionpoints(co[i],co[j]), red);
    addMargins(lmargin=10mm,bmargin=10mm);
  \end{vasy}
\item \index{intersectionpoints(line,conic)}\index{intersectionpoints(conic,line)}
  % \compiletrue
  \begin{Vcolor}
    point[] intersectionpoints(line l, conic co)
  \end{Vcolor}
  Retourne, sous forme d'un tableau, les points d'intersections de la
  droite \param{l} avec la conique \param{co}.\\
  La routine \code{intersectionpoints(conic,line)} est aussi définie.
\item \index{intersectionpoints(conic,triangle,bool)}\index{intersectionpoints(triangle,conic,bool)}
  % \compiletrue
  \begin{Vcolor}
    point[] intersectionpoints(triangle t, conic co, bool extended=false)
  \end{Vcolor}
  Retourne, sous forme d'un tableau, les points d'intersections du
  triangle \param{t} avec la conique \param{co}. Si \param{extended}
  vaut \code{true} les côtés du triangle sont considérés comme des
  droites; voir la section \href{#section.triangles}{Triangles}.\\
  La routine \code{intersectionpoints(conic,triangle,bool)} est aussi définie.
\end{itemize}

\subsubsection{Opérateurs}
Comme pour les routines précédentes, les opérateurs décrits ici peuvent être utilisées en remplaçant un objet
de type \code{conic} par l'un des types \code{circle}, \code{ellipse},
\code{parabola} ou \code{hyperbola}.
\begin{itemize}
\item \index{@(point,conic)}
  % \compiletrue
  \begin{Vcolor}
    bool operator @(point M, conic co)
  \end{Vcolor}
  Autorise le code \code{point @ conic}.\\
  Retourne \code{true} \ssi le point \param{M} appartient à la conique \param{co}.
\item \index{*(transform,conic)}
  % \compiletrue
  \begin{Vcolor}
    conic operator *(transform t, conic co)
  \end{Vcolor}
  Autorise le code \code{transform*conic}.
\item \index{+(conic,explicit point)}\index{-(conic,explicit point)}
  % \compiletrue
  \begin{Vcolor}
    conic operator +(conic co, explicit point M)
  \end{Vcolor}
  Autorise le code \code{conic+point}.\\
  Retourne le translaté de la conique \param{co} par le vecteur
  $\vec{O\mparam{M}}$.\\
  La routine \code{-(conic,explicit point)} est aussi définie.
\item \index{+(conic,explicit pair)}\index{-(conic,explicit pair)}
  % \compiletrue
  \begin{Vcolor}
    conic operator +(conic co, explicit pair m)
  \end{Vcolor}
  Autorise le code \code{conic+pair}.\\
  Retourne le translaté de la conique \param{co} par le vecteur
  $\vec{\mparam{Om}}$; $m$ représente alors les coordonnées d'un point
  défini relativement au repère dans lequel est défini la conique.\\
  La routine \code{-(conic,explicit pair)} est aussi définie.
\item \index{+(conic,explicit vector)}\index{-(conic,explicit vector)}
  % \compiletrue
  \begin{Vcolor}
    conic operator +(conic co, explicit vector u)
  \end{Vcolor}
  Autorise le code \code{conic+vector}.\\
  Retourne le translaté de la conique \param{co} par le vecteur
  $\vec{\mparam{u}}$.\\
  La routine \code{-(conic,explicit vector)} est aussi définie.
\end{itemize}

\hyperdef{subsubsection}{bqe}{\subsubsection{\index{équation!conique|mainidx}Équations
    de coniques}}
Le type \code{bqe}, pour \emph{Bivariate Quadratic Equation}, permet
d'instancier un objet représentant une équation de conique dans un
repère donné. Sa structure est la suivante:
\begin{center}
  \begin{Vcolor}
    struct bqe
    {
      real[] a;
      coordsys coordsys;
    }
  \end{Vcolor}
\end{center}
\noindent où:
\begin{itemize}
\item \param{a} est un tableau des six coefficients d'une équation de
  la conique donnée sous la forme \[\mparam{a[0]}x^2 + \mparam{a[1]}xy + \mparam{a[2]}y^2 + \mparam{a[3]}x + \mparam{a[4]}y + \mparam{a[5]}=0\]
\item \param{coordsys} est le repère dans lequel cette équation est donnée.
\end{itemize}
Voici la liste des routines concernant les objets de type \code{bqe}:
\begin{itemize}
\item \index{bqe(coordsys,real,real,real,real,real,real)}
  \begin{Vcolor}
    bqe bqe(coordsys R=currentcoordsys, real a, real b, real c, real d, real e, real f)
  \end{Vcolor}
  Retourne un objet de type \code{bqe} représentant l'équation
  $\mparam{a}x^2 + \mparam{b}xy + \mparam{c}y^2 + \mparam{d}x + \mparam{e}y + \mparam{f}=0$
  relativement au repère \param{R}.
\item \index{changecoordsys(coordsys,bqe)}
  \begin{Vcolor}
    bqe changecoordsys(coordsys R, bqe bqe)
  \end{Vcolor}
  Retourne un objet de type \code{bqe} relatif au repère \param{R} et
  représentant la même conique que celle représentée par le
  paramètre \param{bqe}. Cette routine permet donc d'effectuer un
  changement de repère dans une équation quadratique à deux variables.
\item \index{bqe(point,point,point,point,point)}
  \begin{Vcolor}
    bqe bqe(point M1, point M2, point M3, point M4, point M5)
  \end{Vcolor}
  Retourne l'équation de la conique passant par les cinq
  points \param{M1}, \param{M2}, \param{M3}, \param{M4}
  et \param{M5}.\\
  Si les points sont définis relativement au même repère, l'équation
  est relative à ce repère; dans le cas contraire l'équation est
  relative au repère par défaut \code{defaultcoordsys}.
\item \index{conictype(bqe)}
  \begin{Vcolor}
    string conictype(bqe bqe)
  \end{Vcolor}
  Retourne le type de conique représentée par \param{bqe}. Les valeurs
  retournées possibles sont \code{"degenerated"}, \code{"ellipse"},
  \code{"parabola"} et \code{"hyperbola"}.
\item \index{equation(explicit conic)}\index{equation(ellispe)}\index{equation(parabola)}\index{hyperbola}
  \begin{Vcolor}
    bqe equation(explicit conic co)
  \end{Vcolor}
  Retourne, sous forme d'objet de type \code{bqe}, l'équation de la
  conique \param{co}.\\
  Les routines \code{equation(ellispe)}, \code{equation(parabola)} et
  \code{equation(hyperbola)} sont aussi disponibles.
\item \index{canonical(bqe)}
  \begin{Vcolor}
    bqe canonical(bqe bqe)
  \end{Vcolor}
  Retourne l'équation de la conique représentée par \param{bqe} dans
  le repère canonique de la dite conique.
\item \index{conic(bqe)}
  \begin{Vcolor}
    conic conic(bqe bqe)
  \end{Vcolor}
  Retourne la conique dont une équation est représentée par \param{bqe}.
\end{itemize}

\hyperdef{subsubsection}{castingconic}{\subsubsection{\index{casting!conique|mainidx}Coniques
    et \texorpdfstring{\og{}casting\fg{}}{casting}}}
Comme il a déjà été mentionné dans les sections précédentes, le type
\code{conic} permet d'instancier un objet représentant une conique
quelconque. Il est toutefois possible, et souvent recommandé, de
convertir un objet représentant une conique quelconque en une conique
d'un type spécifique afin d'utiliser les propriétés et routines
qui lui sont propres.

Les types spécifiques de coniques sont \code{circle}, lui même un cas
particulier du type \code{ellipse}, \code{parabola} et
\code{hyperbola}; ces type seront décrits dans les sections suivantes.

Ainsi dans l'exemple suivant la conique \param{co} est définie par un
foyer et la directrice correspondante avec une excentricité inférieure à
1. Comme cette conique est une ellipse, on peut affecter la
variable \param{co} à une variable de type \code{ellipse} pour en
récupérer les dimensions.
\begin{vasy}{conic_ellipse}
  import geometry;
  size(10cm);
  point F=(-1,0); line D=line(N,S);
  conic co=conic(F, D, 0.85); dot("$F$", F); draw(co, linewidth(bp));

  ellipse el=co; dot("$C$", el.C, S);
  distance(format("$2c=%f$", el.c),el.F1, el.F2, 3cm, joinpen=dashed);
  distance(format("$2a=%f$", el.a), relpoint(el,0), relpoint(el,0.5), 3cm,
  joinpen=dashed);
  distance(format("$2b=%f$", el.b), relpoint(el,0.25), relpoint(el,0.75), 5.25cm,
  joinpen=dashed);
  dot("$F'$", el.F2, W);
\end{vasy}
Du point de vue du fonctionnement interne de \geo, certaines routines
s'appliquant à un objet de type \code{conic} font appel en fait à des
routines équivalentes s'appliquant à une conique spécifique; cela permet
d'optimiser certains calculs. Inversement, des routines relatives à un
type spécifique de conique utilisent de façon sous-jacente des
routines relatives à une conique quelconque.\\
Les types spécifiques de coniques sont décrits ci-après.

\hyperdef{subsection}{circle}{\subsection{\index{cercle|mainidx}\index{ellipse|mainidx}Cercles}}
\subsubsection{Routines de bases}
En dehors des routines concernant les objets de type \code{conic}, voici d'autres routines permettant de définir un
objet de type \code{circle}:
\begin{itemize}
\item \index{circle(explicit point,real)}\index{circle(pair,real)}%
  \compiletrue%
  \begin{Vcolor}
    circle circle(explicit point C, real r)
  \end{Vcolor}
  Renvoie le cercle de centre \param{C} et de rayon \param{r}.\\
  Depuis la version 2{.}10 d'\asymptote la routine
  \code{circle circle(pair C, real r)} n'est
  plus redéfinie afin de renvoyer un objet de type \code{circle} comme
  c'était le cas dans les versions précédentes; ceci oblige à
  utiliser le \og{}casting\fg{} de \code{pair} à \code{point} dans le code
  \code{circle cle = circle((point)(1,2), 2)} et permet ainsi d'obtenir le
  cercle de centre \code((1,2)) dans le repère
  courant \param{currentcoordsys} et rayon 2.

  L'exemple suivant illustre la différence entre le code
  \code{circle((point)(0,0),R);} qui définit le cercle bleu dans le repère courant et
  \code{circle(point(defaultcoordsys,(0,0)), R);} qui définit le cercle rouge dans
  le repère par défaut; évidemment si la
  variable \param{currentcoordsys} n'est pas modifiée les deux codes
  sont équivalents.
  \compiletrue%
  \begin{bvasy}{circlepointradius}
    import geometry;
    size(6cm,0);
    currentcoordsys=cartesiansystem((1,1), i=(1,1),
    j=(-0.5,.75));
    show("$O'$","$\vec{u}$", "$\vec{v}$", currentcoordsys,
    ipen=blue, xpen=invisible);
    show(defaultcoordsys);
    real R=2;
    circle C=circle((point)(0,0), R);
    draw(C, bp+0.8*blue);
    circle Cp=circle(point(defaultcoordsys,(0,0)), R);
    draw(Cp, bp+0.8*red);
  \end{bvasy}
\item \index{circle(point A, point B)}%
  \compiletrue%
  \begin{Vcolor}
    circle circle(point A, point B)
  \end{Vcolor}
  Renvoie le cercle de diamètre \param{AB}.
\item \index{circle(point A, point B)}\index{circumcircle(point,point,point)}%
  \compiletrue%
  \begin{Vcolor}
    circle circle(point A, point B, point C)
  \end{Vcolor}
  Renvoie le cercle passant par les points
  distincts \param{A}, \param{B} et \param{C}.\\
  Un alias de cette routine est \code{circle circumcircle(point A, point B, point C)}.
\item \index{incircle(point,point,point)}%
  \compiletrue%
  \begin{Vcolor}
    circle incircle(point A, point B, point C)
  \end{Vcolor}
  Renvoie le cercle inscrit du triangle ABC.
\item \index{excircle(point,point,point)}%
  \compiletrue%
  \begin{Vcolor}
    circle excircle(point A, point B, point C)
  \end{Vcolor}
  Renvoie le cercle exinscrit du triangle ABC tangent à (AB).
\end{itemize}
\index{clipdraw(picture,Label,path,align,pen,arrowbar,arrowbar,real,real,Label,marker)}%
Dans l'exemple suivant on remarquera l'utilisation de la routine
\code{clipdraw} qui trace un chemin en se restreignant aux dimensions de l'image
finale.
\compiletrue%
\begin{bvasy}{circles_point}
  import geometry;
  size(9cm);
  green=0.8green; blue=0.8blue; red=0.8red;
  pen bpp=linewidth(bp);
  point A=(-1,0), B=(2,0), C=(0,2);
  draw(line(A,B),bpp); draw(line(A,C),bpp);
  draw(line(B,C),bpp);
  circle cc=circle(A,B,C);
  draw(cc, bp+blue); dot(cc.C, blue);
  circle ic=incircle(A,B,C);
  draw(ic, bp+red); dot(ic.C, red);
  circle ec=excircle(A,B,C);
  clipdraw(ec, bp+green); dot(ec.C, green);
  ec=excircle(A,C,B);
  clipdraw(ec, bp+green); dot(ec.C, green);
  ec=excircle(C,B,A);
  clipdraw(ec, bp+green); dot(ec.C, green);
  dot("G", centroid(A,B,C), NE);
\end{bvasy}
Des routines spécifiques à la géométrie du triangle permettent
d'obtenir le même résultat de façon plus élégante, voir la section \href{#section.triangle}{Triangles}.

\subsubsection{\texorpdfstring{Du type \og{}circle\fg{} au type
    \og{}path\fg{}}{Du type «circle» au type «path»}}
La conversion d'un objet de type \code{circle} en \code{path}
s'effectue suivant les règles suivantes:
\begin{itemize}
\item le chemin est cyclique, orienté dans le sens trigonométrique;
\item le premier point du chemin, celui renvoyé par la
  routine \code{pair point(path g, real t)} pour \param{t=0}, est le
  point d'intersection du cercle avec la demi-droite issue du centre
  et de direction \og{}le premier vecteur du repère dans lequel le
  cercle est défini\fg{};
\item le nombre de points du chemin est fonction du rayon du cercle; il
  est calculé par la routine\linebreak
  \index{circlenodesnumber(real)}\code{int circlenodesnumber(real r)}
  qui dépend elle-même de la variable
  \index{circlenodesnumberfactor}\code{circlenodesnumberfactor}.
\end{itemize}
\compiletrue%
\begin{bvasy}{circle_dot}
  import geometry;
  size(7cm,0);
  currentcoordsys=cartesiansystem((2,2), i=(-1,-1),
  j=(0,1));
  show("$O'$","$\vec{u}$", "$\vec{v}$",
  currentcoordsys, ipen=blue, xpen=invisible);
  show(defaultcoordsys);
  circle C=circle((point)(0.5,-1), 3);
  draw(C, 2bp+0.8*blue, Arrow(3mm));
  circle Cp=circle(point(defaultcoordsys,(1,1)), 4);
  draw(Cp, dotsize()+0.8*red, Arrow(3mm));
  dot((path)Cp);
\end{bvasy}
\subsubsection{Les opérateurs}
En dehors des opérateurs s'appliquant aux objets de type \code{conic},
voici la liste d'autres opérateurs définis pour les objets de type \code{circle}.
\begin{itemize}
\item \index{*(real,explicit circle)}\index{/(explicit circle,real)}%
  \compiletrue%
  \begin{Vcolor}
    circle operator *(real x, explicit circle c)
  \end{Vcolor}
  Autorise le code \code{real*circle}.\\
  Renvoie le cercle de même centre que \param{c} et de rayon \param{x}
  fois celui de \param{c}.\\
  L'opérateur \code{circle operator /(explicit circle c, real x)} est
  aussi défini.
\item \index{\circonflexe(point M, explicit circle c)}%
  \compiletrue%
  \begin{Vcolor}
    real operator ^(point M, explicit circle c)
  \end{Vcolor}
  Autorise le code \code{point\circonflexe{}circle}.\\
  Renvoie la puissance de \param{M} par rapport à \param{c}.
\item \index{@(point,explicit circle)}%
  \compiletrue%
  \begin{Vcolor}
    bool operator @(point M, explicit circle c)
  \end{Vcolor}
  Autorise le code \code{point @ circle}.\\
  Renvoie \code{true} \ssi le point \param{M} appartient au cercle \param{c}.
\item \index{circle to ellipse}%
  \compiletrue%
  \begin{Vcolor}
    ellipse operator cast(circle c)
  \end{Vcolor}
  Permet le \og{}casting\fg{} \code{circle} vers \code{ellipse}.\\
  Le \og{}casting\fg{} de \code{ellipse} vers \code{circle} est aussi
  défini.\\
  On notera que l'opérateur \code{*(transform t, circle c)} n'existe pas;
  par le jeu du \og{}casting\fg{}, c'est l'opérateur
  \code{ellipse operator *(transform t, ellipse el)} qui est utilisé
  lors de l'exécution du code \code{transform*circle}.\\
  Ainsi le code \code{scale(2)*circle} renvoie un objet de type
  \code{ellipse} mais il est possible d'écrire
  \code{circle=scale(2)*circle} alors que le code
  \code{circle=xscale(2)*circle} génère une erreur.
\end{itemize}

\subsubsection{Autres routines}
En dehors des routines s'appliquant aux objets de type \code{conic},
voici la liste des routines spécifiques aux objets de type \code{circle}.
\begin{itemize}
\item \index{radicalcenter(circle,circle)}%
  \compiletrue%
  \begin{Vcolor}
    point radicalcenter(circle c1, circle c2)
  \end{Vcolor}
  Renvoie le pied de l'axe radical des deux cercles \param{c1}
  et \param{c2}.\\
  Le repère dans lequel est défini le point renvoyé est celui de \param{c1}.
\item \index{radicalcenter(circle,circle,circle)}%
  \compiletrue%
  \begin{Vcolor}
    point radicalcenter(circle c1, circle c2, circle c3)
  \end{Vcolor}
  Renvoie le centre radical des trois cercles \param{c1}, \param{c2}
  et \param{c3}.
\item \index{radicalline(circle,circle)}%
  \compiletrue%
  \begin{Vcolor}
    line radicalline(circle c1, circle c2)
  \end{Vcolor}
  Renvoie l'axe radical des deux cercles \param{c1}
  et \param{c2}.
\item \index{tangents(circle,point)}%
  \compiletrue%
  \begin{Vcolor}
    line[] tangents(circle c, point M)
  \end{Vcolor}
  Renvoie les tangentes éventuelles à \param{c} passant
  par \param{M}.
  % \compiletrue
  \begin{bvasy}{tangentes_point_cercle}
    import geometry;
    size(7.5cm,0);

    point A=(2.5,-1); dot("$A$", A, SW);
    circle C=circle(A,1); draw(C, linewidth(bp));

    path Cp=shift(A)*scale(2)*unitcircle;
    draw(Cp, grey);
    for (int i=0; i < 360; i+=45) {
      point M=relpoint(Cp, i/360);
      dot(format("$M_%f$", i/45), M, 2*unit(M-A));
      draw(tangents(C, M), 0.8*red);
    }
    addMargins(10mm,10mm);
  \end{bvasy}
\item \index{tangent(circle,point)}%
  \begin{Vcolor}
    line tangent(circle c, point M)
  \end{Vcolor}
  Renvoie la tangente à \param{c} au point d'intersection de \param{c}
  avec la demi-droite d'origine \param{c.C} passant par \param{M}. Le
  point de tangence peut être obtenu avec la routine
  \code{point(circle c, point M)}\index{point(circle,point)}.
\item \index{tangent(circle,explicit vector)}%
  \begin{Vcolor}
    line tangent(circle c, explicit vector v)
  \end{Vcolor}
  Renvoie la tangente à \param{c} au point d'intersection de \param{c}
  avec la demi-droite d'origine \param{c.C} orientée par le
  vecteur \param{v}. Le point de tangence peut être obtenu avec la routine
  \code{point(circle c, vector v)}\index{point(circle,vector)}.
  % \compiletrue
  \begin{bvasy}{tgt_circle_vector}
    import geometry;
    size(5cm);

    circle cle=circle((point)(2,1),1.5);
    draw(cle, linewidth(bp));
    dot("$C$", cle.C);

    vector v=(-1,-2);
    show("$\vec{v}$",v);

    line tgt=tangent(cle,v);
    draw(tgt, bp+0.8*red);
    draw("$\vec{v'}$",cle.C--(cle.C+tgt.v), Arrow);
    dot(point(cle,v));
  \end{bvasy}
\item \index{tangent(circle,abscissa)}
  % \compiletrue
  \begin{Vcolor}
    line tangent(circle c, abscissa x)
  \end{Vcolor}
  Retourne la tangente à \param{c} au point de \param{c}
  d'\href{#section.abscissa}{abscisse} \param{x}.
\item \index{point(explicit circle,real)}
  % \compiletrue
  \begin{Vcolor}
    point point(explicit circle c, real x)
  \end{Vcolor}
  Retourne le \code{point} de \param{c} marquant le même
  point que le \code{pair} retourné par le code
  \code{point((path)c,x)}.
\item \index{relpoint(explicit circle,real)}
  % \compiletrue
  \begin{Vcolor}
    point relpoint(explicit circle c, real x)
  \end{Vcolor}
  Retourne le point de \param{c} correspondant à la fraction \param{x}
  du périmètre de \param{c}.
  \begin{bvasy}{relpoint_circle}
    import geometry;
    size(6cm,0);
    currentcoordsys=cartesiansystem((0,0), i=(1,0.5),
    j=(-0.5,.75));
    show(currentcoordsys, xpen=invisible);

    point A=(2.5,2); dot("$A$", A, S, red);
    real R=2;
    circle C=circle(A,R);
    draw(C, linewidth(bp));

    dot("relpoint(C, 0)", relpoint(C,0), 2W);
    dot("relpoint(C, 0.25)", relpoint(C,0.25), 2SE);
    dot("relpoint(C, 0.5)", relpoint(C,0.5), 2E);
    dot("relpoint(C, -0.25)", relpoint(C, -0.25), 2NW);
    dot("relpoint(C, 1.125)", relpoint(C, 1.125), 2N);
  \end{bvasy}
\item \index{angpoint(explicit circle,real)}
  % \compiletrue
  \begin{Vcolor}
    point angpoint(explicit circle c, real x)
  \end{Vcolor}
  Retourne le point de \param{c} d'angle \param{x} degrés.
  \begin{bvasy}{angpoint_circle}
    import geometry;
    size(6cm,0);
    currentcoordsys=cartesiansystem((0,0), i=(1,0.5),
    j=(-0.5,.75));
    show(currentcoordsys, xpen=invisible);
    point A=(2.5,2); dot("$A$", A, S, red);
    real R=2;
    circle C=circle(A,R);
    draw(C, linewidth(bp));

    dot("angpoint(C, 0)", angpoint(C,0), 2W);
    dot("angpoint(C, 45)", angpoint(C,45), 2N);
    dot("angpoint(C, 135)", angpoint(C,135), 2E);
    dot("angpoint(C, 270)", angpoint(C, 270), 2NW);
    dot("angpoint(C, -45)", angpoint(C, -45), 2W);
  \end{bvasy}
\item \index{curpoint(explicit circle,real)}
  % \compiletrue
  \begin{Vcolor}
    point curpoint(explicit circle c, real x)
  \end{Vcolor}
  Retourne le point de \param{c} dont l'abscisse curviligne est \param{x}.
  \begin{bvasy}{curpoint_circle}
    import geometry;
    size(6cm,0); real R=2;
    currentcoordsys=cartesiansystem((0,0), i=(1,0.5),
    j=(-0.5,.75));
    show(currentcoordsys, xpen=invisible);
    point A=(2.5,2); dot("$A$", A, S, red);
    circle C=circle(A,R); draw(C, linewidth(bp));
    draw(rotate(A-point(C,0))*("$R="+(string)R+"$"),
    A--point(C,0), S, Arrows);

    dot("curpoint(C, 0)", curpoint(C,0), 2W);
    dot("curpoint(C, pi)", curpoint(C,pi), 2SE);
    dot("curpoint(C, 3*pi/2)", curpoint(C,3*pi/2), 2E);
    dot("curpoint(C, -pi)", curpoint(C, -pi), 2NW);
    dot("curpoint(C, 2pi)", curpoint(C, 2*pi), 2E);
  \end{bvasy}
\end{itemize}
D'autres routines sont définies pour les objets de type \code{circle},
elles sont accessibles via des routines utilisant le type \code{ellipse}.

Pour terminer cette section notons qu'il est possible d'utiliser un objet
de type \code{circle} comme une inversion\index{inversion}. On pourra se
reporter à la section \href{#section.inversion}{Inversions} pour plus
de détails.

Voici quelques exemples d'utilisations des routines précédemment décrites:
\begin{itemize}
\item Construction des deux cercles passant par les points $A$ et $B$
  donnés et tangents à la droite $(d)$ donnée.
  % \compiletrue
  \begin{vasy}{circle_2pt_tangent}
    import geometry;
    size(10cm,0);
    pen bpp=linewidth(bp);
    line l=line(origin,(1,-0.25)); draw("$(d)$", l, bpp);
    point A=(1,1.5), B=(0.75,2.5);
    line AB=line(A,B);
    point B1=reflect(l)*B, I=intersectionpoint(l,AB), B2=rotate(180,I)*B;
    dot("$I$", I, NE); dot("$B_1$", B1, SW); dot("$B_2$", B2, SE);

    draw(B--B1, grey+dashed, StickIntervalMarker(2,2,grey));
    markrightangle(B,midpoint(B--B1),I, grey);
    draw(B--B2, grey+dashed, StickIntervalMarker(2,1,grey));
    draw(complementary(segment(B,B2)));

    circle C=circle(A,B1,B2); draw(C, 0.8*blue);
    point[] T=intersectionpoints(l,C);
    dot("$T_0$",T[0], NE); dot("$T_1$",T[1], N+NW);

    circle C1=circle(A,B,T[0]), C2=circle(A,B,T[1]);
    clipdraw(C1, bpp+0.8*red); clipdraw(C2, bpp+0.8*red);
    dot("$O_1$", C1.C, W); dot("$O_2$", C2.C, SW); dot("$A$", A, NE); dot("$B$", B, NE);

    draw(A--T[0]--B1, grey); markangle(A,T[0],B1, grey);
    draw(A--T[1]--B1, grey); markangle(B1,T[1],A, grey);
    draw(B2--B1, grey); markangle(A,B2,B1, grey);
  \end{vasy}
\item \hypertarget{exemple_inversion}{Deux points} du plan et leurs inverses sont cocycliques,
  sur le cercle othogonal au cercle d'inversion.
  % \compiletrue
  \begin{bvasy}{inversion_pre}
    import geometry;
    size(6.5cm,0); currentpen=linewidth(bp);
    point O=origin, M=(2,1), P=(2,-1);
    dot("O", O, W);
    inversion t=inversion(2,O);
    point Mp=t*M, Pt=t*P;
    circle C=circle(M,P,Mp); draw(C);
    dot("M", M, N, blue); dot("P", P, S, blue);
    dot("M'", Mp, red); dot("P'", Pt, red);
    circle Ct=circle(t); clipdraw(Ct, 0.8*red);
    point[] T=intersectionpoints(C,Ct);
    draw(line(O,false,T[0])); draw(line(O,false,T[1]));
  \end{bvasy}
\item Étant donnés trois cercles $\mathscr{C}_{1}$,
  $\mathscr{C}_{2}$ et $\mathscr{C}_{3}$ tels que $r_{3}<r_{1}$ et
  $r_{3}<r_{2}$, comment construire des cercles simultanément tangents à ces
  cercles ?

  Le principe de la construction illustrée ci-après est le suivant:
  \begin{itemize}
  \item On note $S_{1}$ et $S_{2}$ les inversions de rapport positif
    transformant $\mathscr{C}_{2}$ en $\mathscr{C}_{3}$ et $\mathscr{C}_{1}$ en
    $\mathscr{C}_{3}$ respectivement;
  \item on considère un point $M$ sur le cercle $\mathscr{C}_{3}$ et
    l'on note $M_{1}$ et $M_{2}$ son image par $S_{1}$ et $S_{2}$ respectivement;
  \item on note $\mathscr{C}$ le cercle passant par $M$, $M_{1}$ et $M_{2}$;
  \item l'axe radical $(d)$ des cercles $\mathscr{C}_{3}$ et
    $\mathscr{C}$ coupe la droite des centres d'inversions
    $(S_{1}S_{2})$ en $H$; on note $\mathscr{C'}$ le cercle de
    diamètre $\left[HO_{3}\right]$ où $O_{3}$ est le centre de $\mathscr{C}_{3}$;
  \item le cercle $\mathscr{C'}$ coupe $\mathscr{C}_{3}$ en deux
    points $T_{0}$ et $T_{1}$;
  \item le cercle passant par $T_{0}$ et par les images $T'_{0}$ et
    $T''_{0}$ de $T_{0}$ par $S_{1}$ et $S_{2}$ respectivement est une
    solution;
  \item le cercle passant par $T_{1}$ et par les images $T'_{1}$ et
    $T''_{1}$ de $T_{1}$ par $S_{1}$ et $S_{2}$ respectivement est une
    autre solution.
  \end{itemize}
  \compiletrue%
  \begin{vasy}{apollonius}
    import geometry;
    size(9.5cm,0); usepackage("mathrsfs"); currentpen=fontsize(8); pen bpp=linewidth(bp);
    circle C1=circle((point)(0,0),2), C2=circle((point)(5,5), 3), C3=circle((point)(6,-2),1);
    draw(Label("$\mathscr{C}_1$",Relative(0.375)), C1, bp+0.8*red);
    draw("$\mathscr{C}_2$", C2, bp+0.8*red);
    dot(C1.C, 0.8*red); dot(C2.C, 0.8*red); dot(C3.C, 0.8*red);
    inversion S1=inversion(C2,C3), S2=inversion(C1,C3);
    dot("$S_1$", S1.C, 2S+W); dot("$S_2$", S2.C, 2S);
    line cl=line(S1.C,S2.C); draw(cl);
    point M=relpoint(C3,0.125), M2=S2*M, M1=S1*M;
    dot("$M$", M, 2*E); dot("$M_2$", M2, NW); dot("$M_1$", M1, 2*dir(-10));
    draw(segment(S2.C,M2), dashed+grey); draw(segment(S1.C,M1), dashed+grey);
    circle C=circle(M,M2,M1);
    draw(Label("$\mathscr{C}$", Relative(0.375)), C, lightblue);
    line L=radicalline(C,C3); draw("$(d)$", L, grey);
    point H=intersectionpoint(L,cl); dot("$H$", H, 2*dir(260));
    circle Cp=circle(H,C3.C);
    clipdraw(Label("$\mathscr{C'}$", Relative(0.9)), Cp, lightblue);
    point[] T=intersectionpoints(Cp,C3);
    point[][] Tp= new point[][] {{S2*T[0], S1*T[0]},{S2*T[1], S1*T[1]}};
    draw(S2.C--Tp[0][0], dashed+grey); draw(S1.C--Tp[0][1], dashed+grey);
    draw(S2.C--Tp[1][0], dashed+grey); draw(S1.C--Tp[1][1], dashed+grey);
    dot(Label("$T_0$",UnFill), T[0], 2*dir(-20));
    dot(Label("$T_1$",UnFill), T[1], W);
    dot("$T''_0$", Tp[0][0], SW); dot("$T'_0$", Tp[0][1], NE);
    dot("$T''_1$", Tp[1][0], W); dot("$T'_1$", Tp[1][1], N);
    draw(Label("$\mathscr{T}_0$", Relative(0.375)), circle(T[0],Tp[0][0],Tp[0][1]), bpp);
    draw(Label("$\mathscr{T}_1$", Relative(0.375)), circle(T[1],Tp[1][0],Tp[1][1]), bpp);
    draw(Label("$\mathscr{C}_3$",Relative(0.625),UnFill), C3, bp+0.8*red);
  \end{vasy}
\item En prenant les quatre combinaisons possibles pour les inversions
  $S_{1}$ et $S_{2}$, on obtient de même les huit cercles tangents à trois
  cercles donnés:
  \compiletrue%
  \begin{vasy}{all_apollonius}
    import geometry;
    size(18cm,0); int shx=18;
    circle C1=circle((point)(0,0),2), C2=circle((point)(5,5), 3), C3=circle((point)(6,-2),1);
    picture disc;
    fill(disc,(path)C1); fill(disc,(path)C2); fill(disc,(path)C3);
    transform tv=shift(S), th=shift(E);
    int k=0, l=0;
    for (int i=0; i < 2 ; ++i)
    for (int j=0; j < 2; ++j) {
      picture[]  tpic; tpic[0]=new picture; tpic[1]=new picture;
      add(tpic[0], disc); add(tpic[1], disc);
      inversion S1=inversion(C2,C3, sgnd(i-1)), S2=inversion(C1,C3, sgnd(j-1));
      line cl=line(S1.C,S2.C);
      point M=relpoint(C3,0.125), M2=S2*M, M1=S1*M;
      circle C=circle(M,M2,M1);
      line L=radicalline(C,C3);
      point H=intersectionpoint(L,cl);
      circle Cp=circle(H,C3.C);
      point[] T=intersectionpoints(Cp,C3);
      point[][] Tp= new point[][] {{S2*T[0], S1*T[0]},{S2*T[1], S1*T[1]}};
      draw(tpic[0], circle(T[0],Tp[0][0],Tp[0][1]), bp+0.8*red);
      draw(tpic[1], circle(T[1],Tp[1][0],Tp[1][1]), bp+0.8*red);
      add(tv^(shx*(i+1))*th^(shx*(l))*tpic[0]);
      l=(l+2)%4; ++k;
      add(tv^(shx*(i+1))*th^(shx*(l+1))*tpic[1]);
    }
  \end{vasy}
\end{itemize}

\hyperdef{subsection}{ellipse}{\subsection{\index{ellipse|mainidx}\index{ellipse|mainidx}Ellipses}}
Le type \code{ellipse} ne réserve pas de surprise, il permet
d'instancier un objet représentant une ellipse. Comme le type \code{circle}
est un cas particulier du type \code{ellipse} il est possible
d'instancier un cercle en tant qu'une ellipse d'excentricité nulle et,
inversement, d'instancier une ellipse d'excentricité nulle en tant
qu'un cercle. Enfin, comme il existe une correspondance biunivoque
entre les objets de type \code{ellipse} et ceux de type \code{conic}
ayant une excentricité strictement inférieure à $1$, les objets de
type \code{ellipse} héritent des routines et opérateurs définis pour
ceux de type \code{conic}.

\subsubsection{Routines de bases}
Voici la liste des autres routines permettant de définir un objet de type
\code{ellipse}.
\begin{itemize}
\item \index{ellipse(point,point,real)}
  \begin{Vcolor}
    ellipse ellipse(point F1, point F2, real a)
  \end{Vcolor}
  Retourne l'ellipse de foyers \param{F1} et \param{F2} ayant pour
  demi grand axe \param{a}.
\item \index{ellipse(point,point,point)}
  \begin{Vcolor}
    ellipse ellipse(point F1, point F2, point M)
  \end{Vcolor}
  Retourne l'ellipse de foyers \param{F1} et \param{F2} et passant par \param{M}.
\item \index{ellipse(point,real,real,real)}
  \begin{Vcolor}
    ellipse ellipse(point C, real a, real b, real angle=0)
  \end{Vcolor}
  Retourne l'ellipse de centre \param{C} dont le demi grand axe
  a pour longueur \param{a} dans la direction donnée par \param{dir(angle)} et dont
  le demi petit axe a pour longueur \param{b}.
  % \compiletrue
  \begin{bvasy}{ellipses_angle}
    import geometry;
    size(8cm);

    currentcoordsys=rotate(20)*defaultcoordsys;
    show(currentcoordsys);

    ellipse e0=ellipse((point)(0,0), 3, 1);
    draw(e0, linewidth(bp), Arrow);

    ellipse e1=ellipse((point)(0,0), 3, 1, 45);
    draw(e1, bp+0.8*red, Arrow);

    ellipse e2=ellipse((point)(0,0), 1, 3, 45);
    draw(e2, bp+0.8*blue, Arrow);
  \end{bvasy}
\end{itemize}
\subsubsection{\texorpdfstring{Du type \og{}ellipse\fg{} au type
    \og{}path\fg{}}{Du type «ellipse» au type «path»}}
La conversion d'un objet de type \code{ellipse} en \code{path}
s'effectue suivant les règles suivantes:
\begin{itemize}
\item le chemin est cyclique, orienté dans le sens trigonométrique;
\item le premier point, celui renvoyé par la
  routine \code{pair point(path g, real t)} pour \param{t=0}, est le
  point d'intersection de la demi-droite focale $[F_{1}F_{2})$ avec l'ellipse;
\item le nombre de n\oe{}uds du chemin est fonction des longueurs des
  axes de l'ellipse; il est calculé par la routine
  \index{ellipsenodesnumber(real,real)}\code{int ellipsenodesnumber(real a, real b)}
  qui dépend elle-même de la variable
  \index{ellipsenodesnumberfactor}\code{ellipsenodesnumberfactor};
\item les n\oe{}uds du chemin sont définis en coordonnées polaires
  avec des angles donnés relativement au centre de l'ellipse et
  uniformément répartis dans l'intervalle $\left[0\,;\,360\right[$.
\end{itemize}
\compiletrue%
\begin{bvasy}{ellipse_dot}
  import geometry;
  size(8cm,0);
  ellipsenodesnumberfactor=50;
  ellipse e=ellipse(origin, 4, 2, 180);
  draw(e, Arrow);
  dot((path)e);
\end{bvasy}

\subsubsection{Autres routines}
En dehors des routines s'appliquant aux objets de type \code{conic},
voici la liste des routines spécifiques aux objets de type
\code{ellipse}.
\begin{itemize}
\item \index{focusToCenter(ellipse,real)}\index{centerToFocus(ellipse,real)}
  % \compiletrue
  \begin{Vcolor}
    real centerToFocus(ellipse el, real a)
  \end{Vcolor}
  Permet de convertir un angle donné relativement au centre de
  l'ellipse en l'angle relatif au premier foyer.\\
  La routine \code{real focusToCenter(ellipse,real)} est aussi définie.
\item \index{arclength(ellipse,real,real,bool,polarconicroutine)}
  % \compiletrue
  \begin{Vcolor}
    real arclength(ellipse el, real angle1, real angle2,
    bool direction=CCW,
    polarconicroutine polarconicroutine=currentpolarconicroutine)
  \end{Vcolor}
  Renvoie la longueur de l'arc d'ellipse représenté par \param{el}
  entre les angles \param{angle1} et \param{angle2} parcouru dans le
  sens \param{direction}.\\
  \param{polarconicroutine}\index{polarconicroutine} peut prendre les
  valeurs \code{arcfromfocus}\index{arcfromfocus}, qui est la valeur par défaut de\linebreak
  \code{currentpolarconicroutine}, ou
  \code{arcfromcenter}\index{arcfromcenter}; dans le premier cas les
  angles sont donnés relativement au premier foyer, dans le
  second, ils sont donnés relativement au centre de l'ellipse.
\item \index{tangents(ellipse,point)}
  % \compiletrue
  \begin{Vcolor}
    line[] tangents(ellipse el, point M)
  \end{Vcolor}
  Renvoie les tangentes éventuelles à \param{el} passant
  par \param{M}.
  % \compiletrue
  \begin{bvasy}{tangentes_point_ellipse}
    import geometry; size(7.5cm,0);
    point A=(2.5,-1); dot(A);
    ellipse C=ellipse(A,3,1); draw(C,linewidth(bp));
    path Cp=shift(A)*xscale(2)*scale(3)*unitcircle;
    draw(Cp, grey);
    for (int i=0; i < 360; i+=45) {
      point M=relpoint(Cp, i/360); dot(M);
      draw(tangents(C, M), 0.8*red);
    }
    addMargins(10mm,10mm);
  \end{bvasy}
\item \index{tangent(ellipse,abscissa)}
  % \compiletrue
  \begin{Vcolor}
    line tangent(ellipse el, abscissa x)
  \end{Vcolor}
  Retourne la tangente à \param{el} au point de \param{el}
  d'\href{#section.abscissa}{abscisse} \param{x}.

  L' exemple suivant illustre la définition d'une ellipse comme image
  d'un cercle par une affinité et une propriété qui en résulte sur ses
  tangentes.
  % \compiletrue
  \begin{vasy}{affinite_cercle_ellipse_tgtes}
    import geometry; size(12cm,0); draw(Ox()^^Oy()); real a=3, b=2;
    circle C=circle(origin,a), Cp=circle(origin,b);
    draw(C, 0.8*blue); draw(Cp, 0.8*green);

    transform T=scale(b/a,Ox(),Oy()), Tp=scale(a/b,Oy(),Ox());
    ellipse e=T*C; draw(e, bp+0.8*red);

    point H=(a/2,0), Hp=(0,-b/2); dot("$H$", H, S); dot("$H'$", Hp);
    line L=line(H,false,H+N), Lp=line(Hp,false,Hp+W);
    point M=intersectionpoints(L,C)[0], NN=intersectionpoints(Lp,Cp)[0];
    point Mp=T*M, NNp=Tp*NN; L=segment(H,M); Lp=segment(Hp,NNp);
    dot("$M$", M, NE); dot("$M'$", Mp, NE); dot("$N$", NN, SW); dot("$N'$", NNp, NE);
    draw(L, dashed); draw(Lp, dashed);

    segment SS=segment(origin,M), SSp=segment(origin,NN);
    draw(SS, 0.8*blue); draw(SSp, 0.8*green);

    line tgM=tangents(C, M)[0]; point P=intersectionpoint(tgM,Ox());
    draw(tgM, 0.8*blue); dot("$P$", P, dir(60));

    line tgN=tangents(Cp, NN)[0]; point Pp=intersectionpoint(tgN,Oy());
    draw(tgN, 0.8*green); dot("$P'$", Pp, dir(30));

    perpendicularmark(tgM,SS, 0.8*blue); perpendicularmark(tgN,SSp, quarter=2, 0.8*green);

    line tgMp=line(P, Mp), tgNp=line(Pp, NNp);
    draw(tgMp, 0.8*red); draw(tgNp, 0.8*red);

    draw(Mp+2tgMp.u--Mp-2tgMp.u, bp+0.8*red, Arrows(3mm));
    draw(NNp+2tgNp.u--NNp-2tgNp.u, bp+0.8*red, Arrows(3mm));
    addMargins(5mm,5mm);
  \end{vasy}
\item \index{point(explicit ellipse,real)}
  % \compiletrue
  \begin{Vcolor}
    point point(explicit ellipse el, real x)
  \end{Vcolor}
  Retourne le \code{point} de \param{el} marquant le même
  point que le \code{pair} retourné par le code
  \code{point((path)el,x)}.
\item \index{relpoint(explicit ellipse,real)}
  % \compiletrue
  \begin{Vcolor}
    point relpoint(explicit ellipse el, real x)
  \end{Vcolor}
  Retourne le point de \param{el} correspondant à la fraction \param{x}
  du périmètre de \param{el}.
  \begin{bvasy}{relpoint_ellipse}
    import geometry;
    size(6cm,0);
    show(currentcoordsys, xpen=invisible);
    point A=(2.5,2); dot("$A$", A, S, red);
    ellipse el=ellipse(A,2,1,45);
    draw(el, linewidth(bp));

    dot("relpoint(el, 0)", relpoint(el,0), 2S);
    dot("relpoint(el, 0.25)", relpoint(el,0.25), 2S);
    dot("relpoint(el, 0.5)", relpoint(el,0.5), 2S+E);
    dot("relpoint(el, -0.25)", relpoint(el, -0.25), 2SW);
    dot("relpoint(el, 1.125)", relpoint(el, 1.125), 2W);
  \end{bvasy}
\item \index{angpoint(explicit ellipse,real)}
  % \compiletrue
  \begin{Vcolor}
    point angpoint(explicit ellipse el, real x,
    polarconicroutine polarconicroutine=currentpolarconicroutine)
  \end{Vcolor}
  Retourne le point de \param{el} d'angle \param{x} degrés
  depuis le centre de l'ellipse\linebreak
  si \param{polarconicroutine=fromCenter}, depuis le premier foyer
  si \param{polarconicroutine=fromFocus}.
  \begin{vasy}{angpoint_ellipse}
    import geometry; size(10cm,0);
    currentcoordsys=cartesiansystem((0,0),i=(1,0.5),j=(-0.5,.75));
    show(currentcoordsys, xpen=invisible);
    ellipse el=ellipse((point)(4,2),3,2,20);
    draw(el); dot("$C$",el.C,2W,red); dot("$F_1$",el.F1,S); dot("$F_2$",el.F2,S);
    point P=angpoint(el, 0);  dot("angpoint(el, 0)", P,E);   draw(el.F1--P);
    point M=angpoint(el, 90); dot("angpoint(el, 90)", M,NW); draw(el.F1--M);
    dot("angpoint(el, 180)", angpoint(el,180), W);
    dot("angpoint(el, 270)", angpoint(el,270), SE);
    dot("angpoint(el, 370)", angpoint(el,370), NE);
    dot("angpoint(el, -45)", angpoint(el,-45), SE);
    point P=angpoint(el, 90, fromCenter);  dot("angpoint(el,90,fromCenter)", P,NW);
    point Q=angpoint(el, -45, fromCenter); dot("angpoint(el,-45,fromCenter)", Q,S);
    draw(el.C--P); draw(el.C--Q);
  \end{vasy}
\item \index{curpoint(explicit ellipse,real)}
  % \compiletrue
  \begin{Vcolor}
    point curpoint(explicit ellipse c, real x)
  \end{Vcolor}
  Retourne le point de \param{c} dont l'abscisse curviligne est \param{x}.
  \begin{bvasy}{curpoint_ellipse}
    import geometry; size(7cm,0);
    show(currentcoordsys, xpen=invisible);
    ellipse el=ellipse((point)(2,2),2,1,25);
    draw(el, linewidth(bp));
    real L=arclength(el);
    dot("0", curpoint(el,0), dir(25));
    dot("L/4", curpoint(el,L/4), dir(115));
    dot("3*L/4", curpoint(el,3*L/4), -dir(115));
    dot("-L/2", curpoint(el, -L/2), -dir(25));
    dot("11*L/8", curpoint(el, 11*L/8), dir(145));
    label("L=arclength(el)",(2,0.25));
  \end{bvasy}
\end{itemize}

\hyperdef{subsection}{parabola}{\subsection{\index{parabole|mainidx}Paraboles}}
C'est le type \code{parabola} qui permet d'instancier une parabole.
Comme il existe une correspondance biunivoque entre les objets de type
\code{parabola} et ceux de type \code{conic} ayant une excentricité
égale à $1$, les objets de type \code{parabola} héritent des
routines et opérateurs définis pour ceux de type \code{conic}.

\subsubsection{Routines de bases}
Les routines disponibles pour définir une parabole sont:
\begin{itemize}
\item \index{parabola(point,line)}
  % \compiletrue
  \begin{Vcolor}
    parabola parabola(point F, line l)
  \end{Vcolor}
  Renvoie la parabole de foyer \param{F} et de directrice \param{l}.
\item \index{parabola(point,point)}
  \begin{Vcolor}
    parabola parabola(point F, point vertex)
  \end{Vcolor}
  Renvoie la parabole de foyer \param{F} et de sommet \param{vertex}.
\item \index{parabola(point,real,real)}
  \begin{Vcolor}
    parabola parabola(point F, real a, real angle)
  \end{Vcolor}
  Renvoie la parabole de foyer \param{F}, de latus rectum \param{a}
  (longueur de la corde focale perpendiculaire à l'axe de la parabole)
  et dont l'axe fait un angle de \param{angle} avec l'axe des
  abscisses du repère dans lequel est défini le point \param{F}.
\item \index{parabola(point,point,point,line)}
  \begin{Vcolor}
    parabola parabola(point M1, point M2, point M3, line l)
  \end{Vcolor}
  Renvoie la parabole passant par les
  points \param{M1}, \param{M2}, \param{M3} et dont la directrice est
  parallèle à la droite \param{l}.
  % \compiletrue
  \begin{bvasy}{parabole_3_points}
    import geometry;
    size(9cm,0);

    draw(box((-2,-3),(6,3)), invisible);
    point M1=(0,0), M2=(4,-2), M3=(2,1);
    pen[] p=new pen[] {black,red,blue,green};
    parabola P;
    for (int i=0; i < 4; ++i) {
      P=parabola(M1,M2,M3,rotate(45*i)*Ox());
      draw(P, bp+0.8*p[i]);
    }
    dot(scale(0.75)*"$M_1$", M1, 2*dir(175));
    dot(scale(0.75)*"$M_2$", M2, 2*dir(25));
    dot(scale(0.75)*"$M_3$", M3, 2*dir(80));
  \end{bvasy}
\end{itemize}

\subsubsection{\texorpdfstring{Du type \og{}parabola\fg{} au type
    \og{}path\fg{}}{Du type «parabola» au type «path»}}
La conversion d'un objet \param{P} de type \code{parabola} en \code{path}
s'effectue suivant les règles suivantes:
\begin{itemize}
\item le chemin est orienté dans le sens trigonométrique;
\item
  le chemin est contenu, si c'est possible:
  \begin{enumerate}
  \item dans l'image courante si les variables \param{P.bmin}
    et \param{P.bmax}, de type \code{pair}, n'ont pas été modifiées;
  \item dans le rectangle \code{box((P.bmin),box(P.bmax))} dans le cas
    contraire.
  \end{enumerate}
  Ainsi dans l'exemple suivant, au moment de la première conversion en
  chemin, la taille de l'image est symbolisée en pointillé et le
  chemin ne peut pas contenir dans ce rectangle. Lors de la deuxième
  conversion, la modification des variables \param{p.bmin}
  et \param{p.bmax} redéfinit la zone de conversion; elle est tracée
  en rouge avec la portion de parabole correspondante.
  % \compiletrue
  \begin{bvasy}{parabola_to_path}
    import geometry;
    size(10cm);

    point F=(2,-1.5);
    dot("$F$",F,N,red);
    parabola p=parabola(F,0.2,90);

    draw(box((0.1,-1),(3,0.5)), dashed);
    draw((path)p, 2*bp+dashed);

    p.bmin=(0,-0.4);
    p.bmax=(2.5,0.75);
    draw(box(p.bmin,p.bmax), red);
    draw((path)p, bp+red);
  \end{bvasy}
\item le nombre de n\oe{}uds du chemin est fonction des angles, donnés
  relativement au foyer en degrés, des extrémités du chemin; il est calculé par la routine
  \linebreak\index{parabolanodesnumber(parabola,real,real)}\code{int parabolanodesnumber(parabola p, real angle1, real angle2)}
  qui dépend elle-même de la variable
  \index{parabolanodesnumberfactor}\code{parabolanodesnumberfactor};
\item les n\oe{}uds du chemin sont définis en coordonnées polaires
  avec des angles donnés relativement au foyer de la parabole et
  uniformément répartis dans l'intervalle dont les extrémités sont
  retournés par la routine
  \code{real[] bangles(picture pic=currentpicture, parabola p)}\index{bangles(picture,parabola)}.
  % \compiletrue
  \begin{bvasy}{dot_parabola}
    import geometry;
    size(6cm);

    point F=(2,-1.5);
    dot("$F$",F,N,red);
    parabola p=parabola(F,0.2,90);

    draw(box((0.6,-1.75),(3,0.5)), invisible);
    parabolanodesnumberfactor=50;
    dot((path)p);
  \end{bvasy}
\end{itemize}

\subsubsection{Autres routines}
En dehors des routines s'appliquant aux objets de type \code{conic},
voici la liste des routines spécifiques aux objets de type
\code{parabola}.
\begin{itemize}
\item \index{tangents(parabola,point)}
  % \compiletrue
  \begin{Vcolor}
    line[] tangents(parabola p, point M)
  \end{Vcolor}
  Retourne les tangentes éventuelles à \param{p} passant
  par \param{M}.
  \begin{bvasy}{tangentes_parabola}
    import geometry; size(8cm,0);
    point F=(0,0); dot("$F$", F, NE);
    parabola p=parabola(F, 0.1, 30);
    draw(p, linewidth(bp));
    point C=shift(2*(p.V-p.F))*p.V;
    circle cle=circle(C, 0.2);
    draw(cle);
    for (int i=0; i < 360; i+=90) {
      point M=C+0.2*dir(i+30);
      dot(scale(0.75)*("$M_"+(string)(i/90)+"$"),
      M, unit(M-C));
      line[] tgt=tangents(p, M);
      draw(tgt, 0.8*red);
      for (int i=0; i < tgt.length; ++i) {
        dot(intersectionpoints(p, tgt[i]), blue);
      } }
  \end{bvasy}
\item \index{tangent(parabola,abscissa)}
  % \compiletrue
  \begin{Vcolor}
    line tangent(parabola p, abscissa x)
  \end{Vcolor}
  Retourne la tangente à \param{p} au point de \param{p}
  d'\href{#section.abscissa}{abscisse} \param{x}.
\item \index{point(explicit parabola,real)}
  % \compiletrue
  \begin{Vcolor}
    point point(explicit parabola p, real x)
  \end{Vcolor}
  Retourne le \code{point} de \param{p} marquant le même
  point que le \code{pair} retourné par le code
  \code{point((path)p,x)}.
\item \index{relpoint(explicit parabola,real)}
  % \compiletrue
  \begin{Vcolor}
    point relpoint(explicit parabola p, real x)
  \end{Vcolor}
  Retourne le \code{point} marquant le même \code{pair} retourné par
  le code \code{relpoint((path)p,x)}.
\item \index{angpoint(explicit parabola,real)}
  % \compiletrue
  \begin{Vcolor}
    point angpoint(explicit parabola p, real x)
  \end{Vcolor}
  Retourne le point de \param{p} d'angle \param{x} degrés.
\item \index{curpoint(explicit parabola,real)}
  % \compiletrue
  \begin{Vcolor}
    point curpoint(explicit parabola p, real x)
  \end{Vcolor}
  Retourne le point de \param{p} dont l'abscisse curviligne
  est \param{x}, l'origine étant le sommet de la parabole.
  \begin{bvasy}{curpoint_parabola}
    import geometry; size(6cm);

    point F=(1,-1.5); dot("$F$",F,N,red);
    parabola p=parabola(F,0.2,110); draw(p);

    dot("0",curpoint(p,0),SE);
    dot("0.5",curpoint(p,0.5));
    dot("-0.5",curpoint(p,-0.5),SW);
    dot("-2",curpoint(p,-2),SW);
    dot("2",curpoint(p,2),E);
  \end{bvasy}
\item Il est possible de récupérer un arc de parabole sous forme de
  \code{path} grâce à la routine
  suivante:\index{arcfromfocus(conic,real,real,int,bool)}
  % \compiletrue
  \begin{Vcolor}
    path arcfromfocus(conic co, real angle1, real angle2, int n=400, bool direction=CCW)
  \end{Vcolor}
  Bien que cette routine soit disponible pour tout type de conique son
  utilisation n'a réellement d'intérêt que pour les paraboles et les
  hyperboles; les arcs d'ellipse possèdent un type spécifique décrit dans
  la section \href{#section.arc}{Arcs}.

  Voici un exemple illustrant l'utilisation de la routine
  \code{arcfromfocus} avec un parabole.
  \begin{vasy}{arcfromfocus_parabola}
    import geometry;
    size(8cm);
    show(currentcoordsys);

    point F=(1,0.5); dot("$F$",F,E,red);
    parabola p=parabola(F,0.2,110); draw(p);

    coordsys Rp=canonicalcartesiansystem(p);
    show(Label("$O'$",align=NW+W,blue), Label("$\vec{u}$",blue),
    Label("$\vec{v}$",blue), Rp, ipen=blue);

    dot("180", angpoint(p,180), dir(-30));
    point P=angpoint(p,55); dot("55",P,NE);

    segment s=segment(F,P); draw(s);
    line l=line(F,F+Rp.i);
    markangle("$"+(string)degrees(l,s)+"^\circ$",l,s,Arrow);

    dot("-55", point(arcfromfocus(p,-55,-55,1),0), W);
    dot("-90", point(arcfromfocus(p,-90,-90,1),0), W);
    draw(arcfromfocus(p,55,-90), bp+0.8*red, Arrow(3mm));
  \end{vasy}
\end{itemize}

\hyperdef{subsection}{hyperbola}{\subsection{\index{conique|mainidx}Hyperboles}}
C'est le type \code{hyperbola} qui permet d'instancier une hyperbole.
Comme il existe une correspondance biunivoque entre les objets de type
\code{hyperbola} et ceux de type \code{conic} ayant une excentricité
strictement supérieure à $1$, les objets de type \code{hyperbola} héritent des
routines et opérateurs définis pour ceux de type \code{conic}.

\subsubsection{Routines de bases}
Les routines disponibles pour définir une hyperbole sont:
\begin{itemize}
\item \index{hyperbola(point,point,real,bool)}
  % \compiletrue
  \begin{Vcolor}
    hyperbola hyperbola(point P1, point P2, real ae, bool byfoci=byfoci)
  \end{Vcolor}
  \begin{description}
  \item[Si \param{byfoci=true}:] renvoie l'hyperbole de demi grand axe
    \param{ae} et de foyers \param{P1} et \param{P2};
  \item[Si \param{byfoci=false}:] renvoie l'hyperbole d'excentricité
    \param{ae} et de sommets \param{P1} et \param{P2};
  \end{description}
  Pour plus de lisibilité, les constantes \code{byfoci}\index{byfoci}
  et \code{byvertices}\index{byvertices} sont définies, elles ont pour valeurs \code{true}
  et \code{false} respectivement.
  \begin{bvasy}{hyperbole_def_1}
    import geometry; size(6cm);
    pen Red=0.8*red; point P1=(-3,0), P2=(3,0);
    draw(box((-5,-5),(5,5)), invisible);
    hyperbola Hf=hyperbola(P1,P2,2);
    draw(Hf, linewidth(bp)); dot("$C$", Hf.C, N);
    dot("$F_1$", Hf.F1); dot("$F_2$", Hf.F2, W);
    dot("$V_1$", Hf.V1, E); dot("$V_2$", Hf.V2, W);
    distance("$a$", Hf.C, Hf.V1, 2cm, joinpen=dotted);
    distance("$c$", Hf.C, Hf.F1, -2cm, joinpen=dotted);
    hyperbola Hv=hyperbola(P1,P2,1.5,byvertices);
    draw(Hv, bp+Red);
    dot("$V'_1$",Hv.V1, W, Red); dot("$V'_2$",Hv.V2, Red);
    dot("$F'_1$",Hv.F1, W, Red); dot("$F'_2$",Hv.F2, Red);
  \end{bvasy}
\item \index{hyperbola(point,real,real,real)}
  % \compiletrue
  \begin{Vcolor}
    hyperbola hyperbola(point C, real a, real b, real angle=0)
  \end{Vcolor}
  Renvoie l'hyperbole de centre \param{C}, de demi grand axe \param{a}
  le long de \code{C{-}{-}C+dir(angle)} et de \og{}demi petit
  axe\fg{} \param{b}.
\item \index{conj(hyperbola)}
  \begin{Vcolor}
    hyperbola conj(hyperbola h)
  \end{Vcolor}
  Retourne l'hyperbole conjuguée de \param{h}.
  % \compiletrue
  \begin{bvasy}{conj_hyperbole}
    import geometry;
    size(8cm);

    point P1=(-3,0), P2=(3,0);
    draw(box((-5,-5),(5,5)), invisible);

    hyperbola H=hyperbola(P1,P2,2.2);

    draw(H, linewidth(bp));
    draw(H.A1^^H.A2, grey);

    draw(conj(H), bp+0.8*red);
  \end{bvasy}
\end{itemize}

\subsubsection{\texorpdfstring{Du type \og{}hyperbola\fg{} au type
    \og{}path\fg{}}{Du type «hyperbola» au type «path»}}
La conversion d'un objet \param{H} de type \code{hyperbola} en \code{path}
s'effectue suivant les règles suivantes:
\begin{itemize}
\item le chemin est constitué de la branche d'hyperbole de
  foyer \param{H.F1}, il est orienté dans le sens trigonométrique;
\item
  le chemin est contenu, si c'est possible:
  \begin{enumerate}
  \item dans l'image courante si les variables \param{H.bmin}
    et \param{H.bmax}, de type \code{pair}, n'ont pas été modifiées;
  \item dans le rectangle \code{box((H.bmin),box(H.bmax))} dans le cas
    contraire.
  \end{enumerate}
  Ainsi dans l'exemple suivant, au moment de la première conversion en
  chemin, la taille de l'image est symbolisée en pointillé et le
  chemin ne peut pas contenir dans ce rectangle. Lors de la deuxième
  conversion, la modification des variables \param{H.bmin}
  et \param{H.bmax} redéfinit la zone de conversion; elle est tracée
  en rouge avec la portion d'hyperbole correspondante.
  % \compiletrue
  \begin{bvasy}{hyperbola_to_path}
    import geometry;
    size(10cm,0);

    point P1=(-3,0), P2=(3,0);
    hyperbola H=hyperbola(P1,P2,2.95);

    draw(box((-6,-1),(-3.5,1)), dashed);
    draw((path)H, 2*bp+dashed);

    H.bmin=(-5.5,0);
    H.bmax=(-2.5,1.25);
    draw(box(H.bmin,H.bmax), red);
    draw((path)H, bp+red);
  \end{bvasy}
\item le nombre de n\oe{}uds du chemin est fonction des angles, donnés
  relativement au foyer en degrés, des extrémités du chemin; il est calculé par la routine
  \linebreak\index{hyperbolanodesnumber(hyperbola,real,real)}%
  \code{int hyperbolanodesnumber(hyperbola p, real angle1, real angle2)}
  qui dépend elle-même de la variable
  \index{hyperbolanodesnumberfactor}\code{hyperbolanodesnumberfactor};
\item les n\oe{}uds du chemin sont définis en coordonnées polaires
  avec des angles donnés relativement au foyer principale \param{H.F1}
  de l'hyperbole et uniformément répartis dans l'intervalle dont les
  extrémités sont retournés par la routine
  \code{real[][] bangles(picture pic=currentpicture, hyperbola p)}\index{bangles(picture,hyperbola)}.
  % \compiletrue
  \begin{bvasy}{dot_hyperbola}
    import geometry;
    size(10cm,0);

    point P1=(-3,0), P2=(3,0);
    draw(box((-8,-4),(8,4)), invisible);

    dot((path)hyperbola(P1,P2,2.7));

    hyperbolanodesnumberfactor=30;
    dot((path)hyperbola(P2,P1,2.7));
  \end{bvasy}
\end{itemize}

\subsubsection{Autres routines}
En dehors des routines s'appliquant aux objets de type \code{conic},
voici la liste des routines spécifiques aux objets de type
\code{hyperbola}.
\begin{itemize}
\item \index{tangents(hyperbola,point)}
  \begin{Vcolor}
    line[] tangents(hyperbola h, point M)
  \end{Vcolor}
  Retourne les tangentes éventuelles à \param{h} passant
  par \param{M}.
  % \compiletrue
  \begin{bvasy}{tangents_hyperbola}
    import geometry; size(10cm,0);
    draw(box((-5,-3),(5,3)), invisible);
    hyperbola h=hyperbola(origin,1.5,1);
    draw(h, linewidth(bp));

    for (int i=0; i < 360; i +=45 ) {
      point M=(1.5*Cos(i), Sin(i));
      dot(M); draw(tangents(h,M)); }
    draw(ellipse(origin,1.5,1), grey);
  \end{bvasy}
\item \index{tangent(hyperbola,abscissa)}
  % \compiletrue
  \begin{Vcolor}
    line tangent(hyperbola h, abscissa x)
  \end{Vcolor}
  Retourne la tangente à \param{h} au point
  d'\href{#section.abscissa}{abscisse} \param{x}.
  \begin{bvasy}{tangent_hyperbola}
    import geometry; size(0,10cm);
    pen bl=0.8blue, re=0.8*red;
    draw(box((-2.25,-1.5),(-0.75,1)), invisible);
    hyperbola h=hyperbola(origin,1.2,1);
    draw((path)h, linewidth(bp));
    draw("directrix", h.D1); dot("$F_1$", h.F1, NW);

    line axis=line(h.F1,h.F2); draw(axis);
    point M=point(h,angabscissa(70)); dot(M, bl);
    line tgt=tangent(h,angabscissa(70)); draw(tgt, bp+bl);
    point P=intersectionpoint(tgt,h.D1); dot(P, bl);
    draw(P--h.F1--M, grey); markrightangle(P,h.F1,M, grey);

    line lr=perpendicular(h.F1, axis); draw(lr);
    point[] plr=intersectionpoints(h,lr);
    dot(plr, re);
    distance(Label("latus rectum",Fill(white)),
    plr[0], plr[1], -2cm, grey, dotted);
    for (int i=0; i < 2; ++i) {
      draw(tangents(h,plr[i])[0], bp+re); }
  \end{bvasy}
\item \index{point(explicit hyperbola,real)}
  % \compiletrue
  \begin{Vcolor}
    point point(explicit hyperbola h, real x)
  \end{Vcolor}
  Retourne le \code{point} de \param{h} marquant le même
  point que le \code{pair} retourné par le code
  \code{point((path)h,x)}.
\item \index{relpoint(explicit hyperbola,real)}
  % \compiletrue
  \begin{Vcolor}
    point relpoint(explicit hyperbola h, real x)
  \end{Vcolor}
  Retourne le \code{point} marquant le même \code{pair} retourné par
  le code \code{relpoint((path)h,x)}.
\item \index{angpoint(explicit hyperbola,real,polarconicroutine)}
  % \compiletrue
  \begin{Vcolor}
    point angpoint(explicit hyperbola h, real x,
    polarconicroutine polarconicroutine=currentpolarconicroutine)
  \end{Vcolor}
  Retourne le point de \param{h} d'angle \param{x} degrés
  depuis le centre de l'hyperbole\linebreak
  si \param{polarconicroutine=fromCenter}, depuis le premier foyer
  si \param{polarconicroutine=fromFocus}. Deux exemples sont donnés
  ci-après.
\item Il est possible de récupérer un arc de d'hyperbole
  grâce aux deux routines suivantes:\index{arcfromfocus(conic,real,real,int,bool)}
  \begin{enumerate}
    % \compiletrue
  \item
    \begin{Vcolor}
      path arcfromfocus(conic co, real angle1, real angle2, int n=400, bool direction=CCW)
    \end{Vcolor}
    Bien que cette routine soit disponible pour tout type de conique son
    utilisation n'a réellement d'intérêt que pour les paraboles et les
    hyperboles, les arcs d'ellipse possèdent un type spécifique décrit dans
    la section \href{#section.arc}{Arcs}.

    Voici un exemple illustrant
    l'utilisation de la routine \code{arcfromfocus} avec une hyperbole.
    \begin{vasy}{arcfromfocus_hyperbola}
      import geometry; size(10cm,0);
      point C=(4,2); dot("$C$", C, E+NE, red);
      hyperbola H=hyperbola(C,1,1,-20); draw(H, linewidth(bp));
      coordsys R=currentcoordsys; show(R);
      coordsys Rp=canonicalcartesiansystem(H);
      show(Label("$O'$",align=SW,blue), Label("$\vec{u}$",blue), Label("$\vec{v}$",blue),
      Rp, ipen=blue);
      dot("$180$", angpoint(H,180), N+2E);
      dot("$-80$", angpoint(H,-80), NE);
      point P=angpoint(H,70); dot("$70$", P, SE);
      draw(arcfromfocus(H,70,-80), bp+red);
      segment s=segment(H.F1,P); draw(s); line l=line(H.F1,H.F1-Rp.i);
      dot("$F_1$", H.F1, N+NW); markangle("$70^\circ$",l,s,Arrow);
      addMargins(rmargin=3cm);
    \end{vasy}
  \item \index{arcfromcenter(hyperbola,real,real,int,bool)}
    \begin{Vcolor}
      path arcfromcenter(hyperbola h, real angle1, real angle2,
      int n=hyperbolanodesnumber(h,angle1,angle2), bool direction=CCW)
    \end{Vcolor}
    Voici un exemple illustrant
    l'utilisation de la routine \code{arcfromcenter} avec une hyperbole.
    % \compiletrue
    \begin{vasy}{arcfromcenter_hyperbola}
      import geometry; size(12cm);
      coordsys R=currentcoordsys; show(R);
      point C=(3,1.25); dot("$C$", C, 2*dir(120), red);
      hyperbola H=hyperbola(C, 2, 1.5, -10); draw(H, linewidth(bp));
      coordsys Rp=canonicalcartesiansystem(H);
      show(Label("$O'$", align=SW,blue), Label("$\vec{u}$",blue),
      Label("$\vec{v}$",blue), Rp, ipen=blue);
      dot("$0$", angpoint(H,0,fromCenter), 2*dir(120));
      dot("$180$", angpoint(H,180,fromCenter), 2*dir(30));
      draw(arcfromcenter(H,-20,30), bp+red); dot("$F_1$", H.F1, N+NW);
      point P=angpoint(H,30,fromCenter); dot("$30$", P, NW);
      segment s=segment(C, P); draw(s);
      markangle("$30^\circ$", Ox(Rp), (line) s, radius=2cm, Arrow);
    \end{vasy}
  \end{enumerate}
\end{itemize}

\hyperdef{section}{arc}{\section{\index{arc|mainidx}Arcs}}
Le type \code{arc} permet d'instancier un arc orienté d'ellipse. La
principale routine pour définir un tel arc est décrite
ci-dessous\index{arc(ellipse,real,real,polarconicroutine,bool)}.
% \compiletrue
\begin{Vcolor}
  arc arc(ellipse el, real angle1, real angle2,
  polarconicroutine polarconicroutine=polarconicroutine(el),
  bool direction=CCW)
\end{Vcolor}
Retourne un arc de l'ellipse \param{el} compris entre les
angles (en degrés) \param{angle1} et \param{angle2} parcouru dans le
sens \param{direction} et donnés relativement au premier foyer
si \param{polarconicroutine=fromFocus}, relativement au centre de
l'ellipse si \param{polarconicroutine=fromCenter}.

La routine \code{polarconicroutine polarconicroutine(conic co)}
\index{polarconicroutine(conic)} utilisée ici pour déterminer la
valeur par défaut du paramètre \param{polarconicroutine} renvoie dans
le cas présent \code{fromCenter} si \param{co} représente un cercle,
\code{currentpolarconicroutine}, qui vaut \code{fromFocus} par défaut,
si \param{co} représente une ellipse.

Il est important de noter que, lors du tracé d'un arc, la
valeur de la variable \code{addpenarc}\index{addpenarc} est ajoutée au stylo
utilisé. Par défaut cette variable a pour valeur \param{squarecap},
afin d'avoir les extrémités droites, ce qui rend l'affichage d'un
arc en pointillé inefficient.\\
Pour contourner ce problème il y a trois solutions:
\begin{enumerate}
\item écrire \code{draw(un\_arc, roundcap+dotted);} au lieux de
  \code{draw(un\_arc, dotted);};
\item affecter la valeur \code{nullpen} à \code{addpenarc}.
\item contacter l'auteur de \geo pour lui faire connaître
  son désaccord quant à la valeur par défaut de \code{addpenline};
\end{enumerate}

Voici quelques exemples qui illustre l'utilisation de la
routine\linebreak \code{arc(ellipse,real,real,polarconicroutine,bool)}
\begin{itemize}
\item L'exemple suivant montre comment obtenir un arc d'ellipse dont
  les angles sont donnés relativement à son premier foyer, ce qui est
  le comportement par défaut. On notera l'utilisation de la routine
  \hyperdef{}{markarc}{\code{markarc}}\index{markarc} qui sera décrite
  ultérieurement.
  % \compiletrue
  \begin{bvasy}{arc_1}
    import geometry; size(6cm,0);
    real a=2, b=1.5;
    point A=(1,1); dot("$A$", A, red);
    ellipse EL=ellipse(A,a,b,90); draw(EL, bp+grey);
    dot("$F_1$", EL.F1, S); dot("$F_2$", EL.F2, N);
    draw(EL.F1--EL.F2);
    arc AE=arc(EL, 45, 270);
    draw(AE, linewidth(bp), Arrow(3mm), BeginBar);
    point Bp=point(AE, 0), Ep=relpoint(AE,1);
    draw(EL.F1--Bp); draw(EL.F1--Ep);
    markangle(format("$%0g^\circ$",AE.angle1),
    EL.F2,EL.F1,Bp, radius=1.5cm, Arrow);
    markangle(Label(format("$%0g^\circ$",AE.angle2),
    Relative(0.35)),
    EL.F2, EL.F1, Ep, radius=0.75cm, Arrow);
  \end{bvasy}
\item L'exemple suivant montre l'effet des
  paramètres \param{polarconicroutine} et \param{direction}. On notera
  l'utilisation de la routine \code{degrees(arc)} qui sera décrite
  ultérieurement.
  % \compiletrue
  \begin{bvasy}{arc_2}
    import geometry; size(8cm,0);
    real a=2, b=1;
    point A=(1,1); dot("$A$",A,S,red);
    ellipse EL=ellipse(A,a,b);
    arc AE=arc(EL, 45, 210, fromCenter);
    draw(AE, linewidth(bp), Arrow(3mm), BeginBar);
    arc AEp=arc(EL, 45, 210, fromCenter, CW);
    draw(AEp, bp+0.8*red, Arrow(3mm));
    circle C=circle(A,a); arc AC=arc(C, 45, 210);
    draw(AC, linewidth(bp), Arrow(3mm), BeginBar);
    arc ACp=arc(C, 45, 210, CW);
    draw(ACp, bp+0.8*red, Arrow(3mm));
    markarc(format("$%0g^\circ$",degrees(AC)),
    AC, radius=1.5cm, Arrow);
    markarc(format("$%0g^\circ$",degrees(ACp)),
    ACp, markpen=0.8*red, Arrow);
  \end{bvasy}
\item L'exemple suivant reprend le code précédant en permutant les angles
  $45^{\circ}$ et $210^{\circ}$.
  \begin{bvasy}{arc_3}
    import geometry; size(8cm,0);
    real a=2, b=1;
    point A=(1,1); dot("$A$",A,S,red);
    ellipse EL=ellipse(A,a,b);
    arc AE=arc(EL, 210, 45, fromCenter);
    draw(AE, linewidth(bp), Arrow(3mm), BeginBar);
    arc AEp=arc(EL, 210, 45, fromCenter, CW);
    draw(AEp, bp+0.8*red, Arrow(3mm));
    circle C=circle(A,a); arc AC=arc(C, 210, 45);
    draw(AC, linewidth(bp), Arrow(3mm), BeginBar);
    arc ACp=arc(C, 210, 45, CW);
    draw(ACp, bp+0.8*red, Arrow(3mm));
    markarc(format("$%0g^\circ$",degrees(AC)),
    AC, radius=1.5cm, Arrow);
    markarc(format("$%0g^\circ$",degrees(ACp)),
    ACp, markpen=0.8*red, Arrow);
  \end{bvasy}
\end{itemize}

\subsection{\texorpdfstring{Du type \og{}arc\fg{} au type
    \og{}path\fg{}}{Du type «arc» au type «path»}}
La conversion d'un objet \param{A} de type \code{arc} en \code{path}
s'effectue suivant les règles suivantes:
\begin{itemize}
\item le chemin est orienté dans le sens \param{A.direction} qui est
  la direction passée en paramètre pour définir l'arc \param{A};
\item le nombre de n\oe{}uds du chemin est calculé par la routine
  \linebreak\index{arcnodesnumber(explicit arc)}%
  \code{int arcnodesnumber(explicit arc a)}
  qui dépend elle-même de la variable\linebreak
  \index{ellispenodesnumberfactor}\code{ellispenodesnumberfactor};
\item les n\oe{}uds du chemin sont définis en coordonnées polaires
  avec des angles donnés relativement au premier foyer ou au centre de
  l'ellipse suivant la valeur de \param{A.polarconicroutine} et
  uniformément répartit dans un intervalle adéquat.
\end{itemize}
% \compiletrue
\begin{bvasy}{dot_arc}
  import geometry;
  size(4cm,0);
  ellipsenodesnumberfactor=100;
  point A=(1,1); dot("$A$",A,S,red);
  ellipse EL=ellipse(A,2,1);
  dot((path)arc(EL, 210, 45, fromCenter));
  circle C=circle(A,2);
  dot((path)arc(C, 210, 45));
\end{bvasy}

\subsection{Les opérateurs}
\begin{itemize}
\item \index{*(transform,explicit arc)}
  \begin{Vcolor}
    arc operator *(transform t, explicit arc a)
  \end{Vcolor}
  Autorise le code \code{transfomr*arc} dont le comportement est sans
  surprise. Dans l'exemple suivant les arcs en couleur sont des images
  de l'arc noir par des transformations affines.
  % \compiletrue
  \begin{vasy}{transform_arc}
    import geometry; size(10cm,0);
    currentcoordsys=rotate(20)*defaultcoordsys;
    point C=(1,1); dot(C);
    ellipse el=ellipse(C,2,1); draw(el, grey);
    arc AE=arc(el, 45, 180, fromCenter); draw(AE, linewidth(bp), Arrow(3mm));
    draw(scale(0.5,C)*AE, bp+0.8red, Arrow(3mm));
    draw(scale(-0.5,C)*AE, bp+0.8blue,Arrow(3mm));
    draw(scale(1.1,C)*AE, bp+0.8*yellow, Arrow(3mm));
    transform t=scale(-0.5,line(el.F1,el.F2), line(S,N));
    draw(t*AE, bp+0.8(red+blue), Arrow(3mm));
  \end{vasy}
  Le même exemple en partant d'un arc de cercle:
  % \compiletrue
  \begin{bvasy}{transform_arc_circle}
    import geometry; size(6cm,0);
    point C=(0,0); dot(C);
    ellipse el=circle(C,2); draw(el, grey);
    arc AE=arc(el, 45, 180, fromCenter);

    draw(AE, linewidth(bp), Arrow(3mm));
    draw(scale(0.5,C)*AE, bp+0.8red, Arrow(3mm));
    draw(scale(-0.5,C)*AE, bp+0.8blue,Arrow(3mm));
    draw(scale(1.1,C)*AE, bp+0.8*yellow, Arrow(3mm));

    transform t=scale(-0.5,Ox(), Oy());
    draw(t*AE, bp+0.8(red+blue), Arrow(3mm));
  \end{bvasy}
\item \index{*(real,explicit arc)}\index{/(explicit arc,real)}
  \begin{Vcolor}
    arc operator *(real x, explicit arc a)
  \end{Vcolor}
  Autorise le code \code{real*arc}.

  Renvoie l'arc \param{a} avec les
  angles \param{a.angle1-(x-1)*degrees(a)/2}
  et \param{a.angle2+(x-1)*degrees(a)/2}. L'opérateur
  \code{/(explicit arc,real)} est aussi défini.

  Dans l'exemple suivant l'arc jaune est obtenu en multipliant l'arc
  noir par $0,5$ et l'arc bleu en le divisant par 3.
  % \compiletrue
  \begin{bvasy}{arc_mult_div_1}
    import geometry; size(8cm,0);

    point A=(1,1); dot("$A$",A,S,red);
    arc C=arc(circle(A,2), 45, 210);
    draw(C,linewidth(3mm));
    markarc(format("%0g",degrees(C)), C, Arrow);

    draw(0.5*C,1.5mm+yellow);

    arc Cp=C/3;
    draw(Cp, 0.75mm+blue);
    markarc(format("%0g",degrees(Cp)),
    radius=25mm, Cp, blue, Arrow);
  \end{bvasy}
  La même chose en partant d'un arc d'ellipse défini depuis le centre
  de l'ellipse:
  % \compiletrue
  \begin{bvasy}{arc_mult_div_2}
    import geometry; size(8cm,0);
    point C=(1,1); dot("$C$", C, 2*dir(80), red);
    arc a=arc(ellipse(C,2,1,45),90,0,fromCenter);
    draw(a, linewidth(3mm));
    markarc(format("%0g", degrees(a)),
    radius=-0.5*markangleradius(), a);

    draw(0.5*a, 1.5mm+yellow);

    arc ap=a/3;
    draw(ap, 0.75mm+blue);
    markarc(format("%0g", degrees(ap)),
    radius=1.5*markangleradius(),ap,blue);
  \end{bvasy}
  Enfin, dans l'exemple suivant, l'arc est défini depuis le premier
  foyer de l'ellipse:
  % \compiletrue
  \begin{bvasy}{arc_mult_div_3}
    import geometry; size(8cm,0);
    point C=(1,1); dot("$C$", C, dir(30), red);

    arc a=arc(ellipse(C,2,1,45), -45, 45);
    draw(a, linewidth(3mm));
    dot("$F_1$", a.el.F1, dir(210), red);
    markarc(format("%0g", degrees(a)),
    radius=2.5*markangleradius(), a);

    draw(0.5*a, 1.5mm+yellow);

    arc ap=a/3;
    draw(ap, 0.75mm+blue);
    markarc(format("%0g", degrees(ap)),
    radius=1.5*markangleradius(),ap,blue);
  \end{bvasy}
\item \index{+(explicit arc,point)}\index{-(explicit arc,point)}%
  \index{+(explicit arc,vector)}\index{-(explicit arc,vector)}
  \begin{Vcolor}
    arc operator +(explicit arc a, point M)
  \end{Vcolor}
  Autorise le code \code{arc+point} qui est un alias de
  \code{shift(point)*arc}.\\
  Les opérateurs
  \code{-(explicit arc,point)}, \code{+(explicit arc,vector)} et
  \code{-(explicit arc,vector)} sont aussi définis.
\item \index{operator @(point,arc)}
  \begin{Vcolor}
    bool operator @(point M, arc a)
  \end{Vcolor}
  Autorise le code \code{point @ arc}. Retourne \code{true} \ssi le
  point \param{M} appartient à l'arc \param{a}.
\item \index{*(inversion,segment)}
  \begin{Vcolor}
    arc operator *(inversion i, segment s)
  \end{Vcolor}
  Autorise le code \code{inversion*segment}.
  Retourne l'image de \param{s} par
  l'\href{#section.inversions}{inversion} \param{i}; on peut
  \href{#inversion_damier}{voir une illustration} de
  \code{inversion*segment} dans la section \href{#section.inversion}{Inversions}.
\end{itemize}

\subsection{Autres routines}
En plus des routines décrites dans cette section
s'ajoutent les routines pour localiser un point sur un objet de type
\code{arc}; elles sont décrites dans la section
\href{#section.abscissa}{Abscisses}.
\begin{itemize}
\item \index{complementary(arc)}
  \begin{Vcolor}
    arc complementary(arc a)
  \end{Vcolor}
  Retourne le complémentaire de l'arc \param{a}.
  % \compiletrue
  \begin{bvasy}{complementary_arc}
    import geometry;
    size(6cm,0);
    ellipse EL=ellipse(origin,2,1);
    arc AE=arc(EL, 210, 45, fromCenter);
    draw(AE, linewidth(bp), Arrow(3mm));
    draw(complementary(AE), bp+0.8*red, Arrow(3mm));
  \end{bvasy}
\item \index{reverse(arc)}
  \begin{Vcolor}
    arc reverse(arc a)
  \end{Vcolor}
  Retourne l'arc inverse de \param{a} comme le ferait la routine
  \code{reverse(path)}.
\item \index{degrees(arc)}\index{angle(arc)}
  \begin{Vcolor}
    real degrees(arc a)
  \end{Vcolor}
  Retourne la mesure en degrés dans $\left[-360\,;\,360\right]$ de
  l'arc orienté représenté par \param{a}.\\
  La routine \code{angle(arc)} est aussi définie pour une mesure en
  radians.
\item \index{arclength(arc a)}
  \begin{Vcolor}
    real arclength(arc a)
  \end{Vcolor}
  Retourne la longueur de l'arc représenté par \param{a}.
\item \index{arclength(arc a)}
  \begin{Vcolor}
    void markarc(picture pic=currentpicture,
    Label L="", int n=1, real radius=0, real space=0,
    arc a, pen sectorpen=currentpen, pen markpen=sectorpen,
    margin margin=NoMargin, arrowbar arrow=None, marker marker=nomarker)
  \end{Vcolor}
  Permet de marquer l'angle représenté par \param{a} avec un arc de
  cercle.\\
  Le paramètre \param{sectorpen} est le stylo utilisé pour
  marquer les segments qui relient le centre ou le foyer de l'arc avec
  ses extrémités.\\
  Le paramètre \param{markpen} est le stylo utilisé pour tracer l'arc
  de cercle qui peut à son tour être marqué à l'aide du
  paramètre \param{marker}.\\
  Des \href{#markarc}{exemples} d'utilisation ont déjà été donnés.
\item \index{intersectionpoints(arc,arc)}
  \begin{Vcolor}
    point[] intersectionpoints(arc a1, arc a2)
  \end{Vcolor}
  Retourne, sous forme de tableau, les points d'intersection de deux
  arcs. Les routines d'intersections d'un objet de type \code{arc}
  avec d'autres objets définis par \geo sont aussi définies; par
  exemple \code{intersectionpoints(conic co, arc a)}\index{intersectionpoints(conic,arc)},
  \code{intersectionpoints(arc a, conic co)}\index{intersectionpoints(arc,conic)},
  \code{intersectionpoints(line l, arc a)}\index{intersectionpoints(line,arc)} etc...
\item \index{arcsubtended(point,point,real)}
  % \compiletrue
  \begin{Vcolor}
    arc arcsubtended(point A, point B, real angle)
  \end{Vcolor}
  Retourne l'arc capable du segment $[\mparam{AB}]$ vu sous un
  angle \param{angle}. Bien que le code \code{un\_arcsubtended.C} permette
  de récupérer le centre de l'arc capable, il est possible de
  l'obtenir directement en utilisant la routine
  \code{point arcsubtendedcenter(point A, point B, real angle)}
  \index{arcsubtendedcenter(point,point,real)}.
  \begin{bvasy}{arcsubtended}
    import geometry; size(7cm,0);
    point A=(-1,0), B=(1,0);
    dot("$A$", A, 2W, red); dot("$B$", B, 2E, red);

    real[] angles=new real[] {60, 110, -60, -110};
    pen[] p=new pen[] {red, blue+red, blue, cyan};
    int i=0;

    for(real a:angles) {
      arc arcsubtended=arcsubtended(A,B,a);
      draw(arcsubtended, bp+0.8*p[i]);
      for (int j=0; j < 2; ++j) {
        point M=relpoint(arcsubtended, 0.25+0.5*j);
        draw(A--M--B, 0.8*p[i]);
        real gle=degrees(B-M)-degrees(A-M);
        markangle(Label(format("%0g",-gle),UnFill),
        B, M, A, radius=sgn(-gle)*30, Arrow, 0.8*p[i]); }
      ++i; }
  \end{bvasy}
  \begin{bvasy}{angle_inscrit}
    import geometry; size(7cm,0);
    point A=(-1,0), B=(1,0);
    dot("$A$", A, S); dot("$B$", B, S);
    pen bpp=linewidth(bp);

    arc Ac=arcsubtended(A,B,30); draw(Ac, bpp);
    dot("$O$", Ac.el.C);
    markarc("$\alpha$", Ac, n=2, radius=1cm,
    sectorpen=bpp, markpen=currentpen);

    for (int i=0; i < 3; ++i) {
      point M=relpoint(Ac, 0.25+0.25*i);
      draw(M--A^^M--B, linewidth(bp));
      markangle("$\frac{\alpha}{2}$", A, M, B); }
  \end{bvasy}
\item \index{arccircle(point,point,real,bool)}
  % \compiletrue
  \begin{Vcolor}
    arc arccircle(point A, point B, real angle, bool direction=CCW)
  \end{Vcolor}
  Retourne l'arc de cercle, centré en \param{A}, depuis \param{B}
  jusqu'à l'image de \param{B} par la rotation de centre \param{A} et
  d'angle \param{angle} parcouru dans le sens \param{direction}.
  \begin{bvasy}{ove}
    import geometry;
    size(6cm);
    point A=(-1,1), B=(1,-1);
    point M=(A+B)/2;

    point P=rotate(90,M)*B;
    arc A1=arccircle(A,B,45), A2=arccircle(B,A,-45,CW),
    A3=arccircle(P,relpoint(A2,1),-90,CW),
    A4=arccircle(M,A,180);
    draw(A1^^A2^^A3^^A4, linewidth(bp));
    shipout(bbox());
  \end{bvasy}
\item \index{arccircle(point,point,point)}
  % \compiletrue
  \begin{Vcolor}
    arc arccircle(point A, point M, point B)
  \end{Vcolor}
  Retourne l'arc de cercle $\stackrel{\frown}{\mparam{AB}}$ passant
  par \param{M}.
  \begin{bvasy}{circumarc_def}
    import geometry;
    size(6cm);
    point A=(-1,0), B=(3,-1), C=(0,1), D=(0,-2);

    draw(arccircle(A,C,B), dotsize()+0.8*red);
    draw(arccircle(A,D,B), dotsize()+0.8*red);

    dot("$A$", A, NW); dot("$B$", B, E);
    dot("$C$", C, NW); dot("$D$", D, SW);
  \end{bvasy}
\item \index{arc(ellipse,point,point,bool)}
  % \compiletrue
  \begin{Vcolor}
    arc arc(ellipse el, point M, point N, bool direction=CCW)
  \end{Vcolor}
  Retourne l'arc de \param{el}, parcouru dans le
  sens \param{direction}, d'extrémités \param{M} et \param{N}
  qui doivent être des points appartenant à \param{el}.\\
  \begin{vasy}{arc_inter_points}
    import geometry; size(8cm);
    point A=(-1,0), B=(1,1), C=(0,1), D=(1,-1);
    dot("$A$",A,S); dot("$B$",B,S); dot("$C$",C,SW); dot("$D$",D,SW);
    ellipse el=ellipse((point)(0,0.5),2,1);
    line l1=line(A,B), l2=line(C,D); draw(l1); draw(l2);
    point[] J=intersectionpoints(l1,el), K=intersectionpoints(l2,el);
    draw(arc(el, J[0],K[0]), 1mm+0.8yellow); draw(arc(el, K[0],J[1]), 1mm+0.8red);
    draw(arc(el, J[1],K[1]), 1mm+0.8blue); draw(arc(el, K[1],J[0]), 1mm+0.8green);
    dot("$J_0$", J[0], 2N); dot("$J_1$", J[1], 2S);
    dot("$K_0$", K[0], 2NE) ; dot("$K_1$", K[1], 2dir(-35));
  \end{vasy}
\item \index{arc(ellipse,abscissa,abscissa,bool)}
  \begin{Vcolor}
    arc arc(ellipse el, explicit abscissa x1, explicit abscissa x2, bool direction=CCW)
  \end{Vcolor}
  Cette routine a le même comportement que la routine précédente mais
  les points sont spécifiés à l'aide
  d'\href{#section.abscissa}{abscisses} par rapport à l'ellipse.
\item \index{arc(explicit arc,point,point)}
  \begin{Vcolor}
    arc arc(explicit arc a, point M, point N)
  \end{Vcolor}
  Retourne la partie de l'arc \param{a} comprise entre \param{M}
  et \param{N}.
  % \compiletrue
  \begin{vasy}{subarc_point}
    import geometry; size(8cm);
    point A=(-1,0), B=(1,1), C=(0,0), D=(1,-1);
    dot("$A$",A,S); dot("$B$",B,S); dot("$D$",D,SW);
    arc c=arc(ellipse(C,2,1,20), 0, 270); draw(complementary(c),dashed+grey);
    line l1=line(A,B), l2=line(C,D);
    point[] J=intersectionpoints(l1,c), K=intersectionpoints(l2,c);
    draw(arc(c,J[0],K[0]), 2bp+0.8yellow); draw(arc(c,K[0],J[1]), 2bp+0.8red);
    draw(arc(c,J[1],relpoint(c,1)), 2bp+0.8green); draw(arc(c,point(c,0),J[0]), 2bp+0.8blue);
    dot("$J_0$",J[0],2N); dot("$J_1$",J[1],N+2W); dot("$K_0$",K[0],2N);
    draw(c, bp+white); draw(l1^^l2);
  \end{vasy}
\item \index{arc(arc,abscissa,abscissa)}
  \begin{Vcolor}
    arc arc(arc el, explicit abscissa x1, explicit abscissa x2)
  \end{Vcolor}
  Cette routine a le même comportement que la routine précédente mais
  les points sont spécifiés à l'aide
  d'\href{#section.abscissa}{abscisses} par rapport à l'ellipse.
\item \index{inverse(real,point,segment)}
  \begin{Vcolor}
    arc inverse(real k, point A, segment s)
  \end{Vcolor}
  Retourne l'image de \param{s} par l'inversion de pôle \param{A} et
  de puissance \param{k}; \href{#inversion_damier}{voir l'illustration}
  de\linebreak \code{inversion*segment} dans la section
  \href{#section.inversion}{Inversions}.
\item \index{tangent(explicit arc,point)}
  \begin{Vcolor}
    line tangent(explicit arc a, point M)
  \end{Vcolor}
  Retourne la tangente à \param{a} au point \param{M} de \param{a}.
\item \index{tangent(explicit arc,abscissa)}
  \begin{Vcolor}
    line tangent(explicit arc a, abscissa x)
  \end{Vcolor}
  Retourne la tangente à \param{a} au point
  d'\href{#section.abscissa}{abscisse} \param{x} donné par rapport
  à \param{a}.
\end{itemize}

\hyperdef{section}{abscissa}{\section{\index{abscisse|mainidx}Abscisses}}
Le type \code{abscissa} permet d'instancier une abscisse sur un objet
de type \code{line}, \code{segment}, \code{conic} et \code{arc}. La
structure d'un objet de type \code{abscissa} est la suivante:
\begin{center}
  \begin{Vcolor}
    struct abscissa {
      real x; int system; polarconicroutine
      polarconicroutine;
      abscissa copy() {...}
    }
  \end{Vcolor}
\end{center}
\begin{description}
\item[\param{x}] est la valeur de l'abscisse.
\item[\param{system}] représente le type d'abscisse:
  \begin{description}
  \item[0] pour une abscisse comme fraction de la longueur d'un chemin;
  \item[1] pour une abscisse curviligne;
  \item[2] pour une abscisse angulaire;
  \item[3] pour une abscisse relative aux n\oe{}ds du chemin.
  \end{description}
  Pour une meilleure lisibilité du code, les constantes suivantes sont
  prédéfinies\index{relativesystem}\index{curvilinearsystem}\index{angularsystem}\index{nodesystem}:
  \begin{Vcolor}
    int relativesystem=0, curvilinearsystem=1, angularsystem=2, nodesystem=3;
  \end{Vcolor}
\item[\param{polarconicroutine}] permet de spécifier le centre de
  référence dans le cas d'une abscisse angulaire; les valeurs
  possibles sont \code{fromCenter} et \code{fromFocus};
\item[\param{abscissa copy()}] retourne la copie de l'abscisse.
\end{description}
\subsection{Définir une abscisse}
Il y a autant de routines pour définir une abscisse que de
types d'abscisses. Une fois une abscisse définie, on peut récupérer le
point d'un objet à cette abscisse par la routine
\code{point(objet,abscisse)}.
\begin{itemize}
\item \index{relabscissa(real)}
  \begin{Vcolor}
    abscissa relabscissa(real x)
  \end{Vcolor}
  Retourne l'abscisse \param{x} comme fraction de la longueur d'un
  chemin.
  On notera que le code \code{point(objet,relabscissa(x))} est
  équivalent à \code{relpoint(objet,x)}.
  % \compiletrue
  \begin{bvasy}{relabscissa}
    import geometry; size(4.5cm);
    currentcoordsys=rotate(45)*defaultcoordsys;
    show(currentcoordsys);
    abscissa rel=relabscissa(0.5);
    ellipse el=ellipse(origin(),2,1,-45); draw(el,linewidth(bp));
    circle c=circle(origin(),1);          draw(c,linewidth(bp));
    dot(point(el,rel), red); dot(point(c,rel), red);
  \end{bvasy}
\item \index{curabscissa(real)}
  \begin{Vcolor}
    abscissa curabscissa(real x)
  \end{Vcolor}
  Retourne l'abscisse curviligne \param{x}.
  On notera que le code \code{point(objet,curabscissa(x))} est
  équivalent à \code{curpoint(objet,x)}.
  % \compiletrue
  \begin{bvasy}{curabscissa}
    import geometry; size(4.5cm);
    currentcoordsys=rotate(45)*defaultcoordsys;
    show(currentcoordsys);
    abscissa cur=curabscissa(pi);
    ellipse el=ellipse(origin(),2,1,-45); draw(el,linewidth(bp));
    circle c=circle(origin(),1);          draw(c,linewidth(bp));
    dot(point(el,cur), red); dot(point(c,cur), red);
  \end{bvasy}
\item \index{angabscissa(real,polarconicroutine)}
  \begin{Vcolor}
    abscissa angabscissa(real x,
    polarconicroutine polarconicroutine=currentpolarconicroutine)
  \end{Vcolor}
  Retourne l'abscisse angulaire \param{x}.
  On notera que le code \code{point(objet,angabscissa(x))} est
  équivalent à \code{angpoint(objet,x)}.
  % \compiletrue
  \begin{bvasy}{angabscissa}
    import geometry;
    size(6cm);
    abscissa x=angabscissa(30);

    ellipse el=ellipse(origin(),2,1,45);
    draw(el,linewidth(bp));

    point M=point(el,x);
    draw(M--el.F1--el.F2);
    dot("$F_1$", el.F1, SE); dot("$F_2$", el.F2, NW);
    markangle((string)x.x, el.F2, el.F1, M);
    draw(tangent(el,x), linewidth(bp));
  \end{bvasy}
\item \index{nodabscissa(real)}
  \begin{Vcolor}
    abscissa nodabscissa(real x)
  \end{Vcolor}
  Retourne l'abscisse \param{x} relative aux n\oe{}ds d'un chemin.
  On notera que le code \code{point(objet,nodabscissa(x))} est
  équivalent à \code{point(objet,x)}.
\end{itemize}

\subsection{Récupérer une abscisse d'un point}
Les routines permettant de récupérer une abscisse d'un point
appartenant à un objet donné portent le même nom que celles décrites
dans le section précédente. Les routines suivantes renvoient
respectivement l'abscisse relative, l'abscisse curviligne, l'abscisse
angulaire et \og{}l'abscisse par n\oe{}ud\fg{} du
point \param{M} appartenant à l'objet spécifié.
\begin{description}
\item[Abscisse relative]\hspace*{0mm}
  \begin{itemize}
  \item \index{relabscissa(line,point)}
    \begin{Vcolor}
      abscissa relabscissa(line l, point M)
    \end{Vcolor}
  \item \index{relabscissa(ellipse,point)}
    \begin{Vcolor}
      abscissa relabscissa(ellipse el, point M)
    \end{Vcolor}
  \item \index{relabscissa(arc,point)}
    \begin{Vcolor}
      abscissa relabscissa(arc a, point M)
    \end{Vcolor}
  \end{itemize}
\item[Abscisse curviligne]\hspace*{0mm}
  \begin{itemize}
  \item \index{curabscissa(line,point)}
    \begin{Vcolor}
      abscissa curabscissa(line l, point M)
    \end{Vcolor}
  \item \index{curabscissa(ellipse,point)}
    \begin{Vcolor}
      abscissa curabscissa(ellipse el, point M)
    \end{Vcolor}
  \item \index{curabscissa(parabola,point)}
    \begin{Vcolor}
      abscissa curabscissa(parabola p, point M)
    \end{Vcolor}
  \end{itemize}
\item [Abscisse angulaire]\hspace*{0mm}
  \begin{itemize}
  \item \index{angabscissa(circle,point)}
    \begin{Vcolor}
      abscissa angabscissa(circle c, point M)
    \end{Vcolor}
  \item \index{angabscissa(ellipse,point,polarconicroutine)}
    \begin{Vcolor}
      abscissa angabscissa(ellipse el, point M, polarconicroutine
      polarconicroutine=currentpolarconicroutine)
    \end{Vcolor}
  \item \index{angabscissa(hyperbola,point,polarconicroutine)}
    \begin{Vcolor}
      abscissa angabscissa(hyperbola h, point M, polarconicroutine
      polarconicroutine=currentpolarconicroutine)
    \end{Vcolor}
  \item \index{angabscissa(parabola,point)}
    \begin{Vcolor}
      abscissa angabscissa(parabola p, point M)
    \end{Vcolor}
  \end{itemize}
\item[\og{}Abscisse par n\oe{}ud\fg{}]\hspace*{0mm}
  \begin{itemize}
  \item \index{nodabscissa(line,point)}
    \begin{Vcolor}
      abscissa nodabscissa(line l, point M)
    \end{Vcolor}
  \item \index{nodabscissa(ellipse,point)}
    \begin{Vcolor}
      abscissa nodabscissa(ellipse el, point M)
    \end{Vcolor}
  \item \index{nodabscissa(parabola,point)}
    \begin{Vcolor}
      abscissa nodabscissa(parabola p, point M)
    \end{Vcolor}
  \end{itemize}
\end{description}

\subsection{Opérateurs}
\index{+(real x, explicit abscissa a)}
\begin{Vcolor}
  abscissa operator +(real x, explicit abscissa a)
\end{Vcolor}
Retourne la copie de \param{a} d'abscisse \param{x+a.x}.

Les opérateurs suivants sont aussi définis:\\
\code{operator +(explicit abscissa,real)}\index{+(explicit abscissa,real)}\\
\code{operator -(real,explicit abscissa)}\index{-(real,explicit abscissa)}\\
\code{operator -(explicit abscissa,real)}\index{-(explicit abscissa,real)}\\
\code{operator -(explicit abscissa a)}\index{operator -(explicit abscissa a)}\\
\code{operator *(real x, explicit abscissa a)}\index{operator *(real x, explicit abscissa a)}\\
\code{operator *(explicit abscissa a, real x)}\index{operator *(explicit abscissa a, real x)}\\
\code{operator /(real x, explicit abscissa a)}\index{/(real x, explicit abscissa a)}\\
\code{operator /(explicit abscissa a, real x)}\index{/(explicit abscissa a, real x)}.

\hyperdef{section}{triangle}{\section{\index{triangle|mainidx}Triangles}}
\hyperdef{subsection}{struct}{\subsection{La structure}}
La structure du type \code{triangle} est un peu plus complexe que
celles déjà rencontrées dans ce document car elle définit
de nouveaux types instanciant des objets indissociables
d'un triangle et qui possèdent eux-mêmes la référence du triangle
auquel ils sont associés. Autrement dit, pour fixer les idées, un
objet \param{TR} de type triangle possède l'objet \param{VA} de
type \code{vertex}, accessible par \param{TR.VA}, qui contient à son
tour l'objet \param{t} de type \code{triangle} dont la valeur est
justement \param{TR}; ainsi \param{TR.VA.t} vaut \param{TR}.

Sachant qu'un objet de type \code{vertex}
représente un sommet d'un triangle, il est alors aisé de définir une
routine renvoyant, par exemple, la première bissectrice d'un triangle
passant par un sommet donné avec comme seul paramètre un objet de type
\code{vertex}, puisque celui-ci contient la référence du triangle dont
il est le sommet.

Voici une version simplifiée de la structure du type \code{triangle};
la structure complète est détaillée
\href{http://piprim.tuxfamily.org/asymptote/geometry/modules/geometry.asy.index.sign.html#struct\%20triangle}{séparément}.
\begin{center}
  \begin{Vcolor}
    struct triangle {
      restricted point A, B, C;

      struct vertex {
        int n;
        triangle t; }

      restricted vertex VA, VB, VC;

      struct side {
        int n;
        triangle t; }

      side AB, BC, CA, BA, AC, CB; }
  \end{Vcolor}
\end{center}
\begin{description}
\item[\param{A}, \param{B} et \param{C}] représentent les points
  marquant les sommets du triangle;
\item[\param{struct vertex}] définit la structure \code{vertex} qui
  permet d'instancier un objet représentant le sommet d'un triangle.
  Bien que cette structure ne soit pas destinée à une utilisation
  classique de \geo il peut être utile d'en connaître les propriétés.

  La propriété \param{n} permet d'associer un sommet au point, de type
  \code{point}, marquant ce sommet:\\
  si $\mparam{n}=1$, le sommet est associé au point \param{A};\\
  si $\mparam{n}=2$, le sommet est associé au point \param{B};\\
  si $\mparam{n}=3$, le sommet est associé au point \param{C};\\
  si $\mparam{n}=4$, le sommet est associé au point \param{A};\\
  etc...\\
  La propriété \param{t} a pour valeur \og{}l'objet, de type triangle,
  auquel appartient le sommet\fg{}.\\
  L'utilisation de cette structure est détaillée dans la section
  \href{#subsection.vertex}{Sommets de triangles}.
\item[\param{VA}, \param{VB} et \param{VC}] représentent abstraitement
  les sommets du triangle, par opposition aux objets
  \code{point} \param{A}, \param{B} et \param{C} qui sont concrètement
  les points marquant le sommet; voir la section
  \href{#subsection.vertex}{Sommets de triangles}.
\item[\param{struct side}] définit la structure \code{side} qui
  permet d'instancier un objet représentant le côté d'un triangle.
  Bien que cette structure ne soit pas destinée à une utilisation
  classique de \geo il peut être utile d'en connaître les propriétés.

  La propriété \param{n} permet d'associer l'objet de type
  \code{side} au côté \textbf{orienté} du triangle:\\
  si $\mparam{n}=1$, le côté représente \param{AB} orienté
  de \param{A} vers \param{B};\\
  si $\mparam{n}=2$, le côté représente \param{BC} orienté
  de \param{B} vers \param{C};\\
  si $\mparam{n}=3$, le côté représente \param{CA} orienté
  de \param{C} vers \param{A};\\
  si $\mparam{n}=4$, le côté représente \param{AB};\\
  etc...\\
  Si \param{n} est négatif l'orientation est inversée.\\
  La propriété \param{t} a pour valeur \og{}l'objet, de type triangle,
  auquel appartient le sommet\fg{}.\\
  L'utilisation de cette structure est détaillée dans la section
  \href{#subsection.vertex}{Côtés de triangles}.
\item[\param{AB}, \param{BC}, \param{CA}, \param{BA}, \param{AC} et \param{CB}]
  représente abstraitement les côtés du triangle, par opposition aux objets
  \code{line} \param{line(TR.AB)}, \param{line(TR.BC)}, \param{line(TR.CA)},
  etc.. qui sont concrètement les droites marquant les côtés du
  triangle \param{TR}; voir la section
  \href{#subsection.vertex}{Côtés de triangles}.
\end{description}

\subsection{Définir et tracer un triangle}
Dans cette section ne seront décrites que les routines de base pour
définir et tracer un triangle. D'autres routines retournant un triangle seront
introduites au fur et à mesure.

\begin{itemize}
\item \index{label(picture,Label,Label,Label,triangle,real,real,pen,filltype)}
  \begin{Vcolor}
    void label(picture pic=currentpicture, Label LA="$A$",
    Label LB="$B$", Label LC="$C$",
    triangle t,
    real alignAngle=0,
    real alignFactor=1,
    pen p=nullpen, filltype filltype=NoFill)
  \end{Vcolor}
  Place les labels \param{LA}, \param{LB} et \param{LC} aux
  sommets du triangle \param{t}, alignés suivant la première bissectrice
  du sommet correspondant. Les paramètres \param{alignAngle}
  et \param{alignFactor} permettent de modifier la direction et la
  longueur de l'alignement.
\item \index{show(picture,Label,Label,Label,Label,Label,Label,triangle,pen,filltype)}
  \begin{Vcolor}
    void show(picture pic=currentpicture,
    Label LA="$A$", Label LB="$B$", Label LC="$C$",
    Label La="$a$", Label Lb="$b$", Label Lc="$c$",
    triangle t, pen p=currentpen, filltype filltype=NoFill)
  \end{Vcolor}
  Trace le triangle \param{t} et affiche les labels aux sommets du triangle ainsi que les
  longueurs de ses côtés. Cette routine est surtout utile pour
  localiser les sommets \param{t.A}, \param{t.B} et \param{t.C} en
  cours de codage.
\item \index{drawline(picture,triangle,pen)}
  \begin{Vcolor}
    void draw(picture pic=currentpicture, triangle t,
    pen p=currentpen, marker marker=nomarker)
  \end{Vcolor}
  Trace le triangle \param{t}; les côtés sont tracés comme des segments.
\item \index{drawline(picture,triangle,pen)}
  \begin{Vcolor}
    void drawline(picture pic=currentpicture, triangle t, pen p=currentpen)
  \end{Vcolor}
  Trace le triangle \param{t}; les côtés sont tracés comme des droites.
\item \index{triangle(point,point,point)}
  \begin{Vcolor}
    triangle triangle(point A, point B, point C)
  \end{Vcolor}
  Renvoie le triangle dont les sommets sont \param{A}, \param{B} et \param{C}.
\item \index{triangleabc(real,real,real,real,point)}
  \begin{Vcolor}
    triangle triangleabc(real a, real b, real c, real angle=0, point A=(0,0))
  \end{Vcolor}
  Retourne le triangle \param{ABC} tel que
  $\mparam{BC}=\mparam{a}$, $\mparam{AC}=\mparam{b}$,
  $\mparam{AB}=\mparam{c}$ et
  $\left(\vec{\imath}\,;\,\vec{\mparam{AB}}\right)=\mparam{angle}$.
  % \compiletrue
  \begin{bvasy}{triangleabc}
    import geometry;
    size(4cm);

    currentcoordsys=cartesiansystem(i=(1,0.5), j=(-0.25,.75));
    show(currentcoordsys);

    triangle t=triangleabc(3,4,5, (1,1));
    show(La="3", Lb="4", Lc="5", t);
  \end{bvasy}
\item \index{triangleAbc(real,real,real,real,point)}
  \begin{Vcolor}
    triangle triangleAbc(real alpha, real b, real c, real angle=0, point A=(0,0))
  \end{Vcolor}
  Retourne le triangle \param{ABC} tel que
  $\left(\vec{\mparam{AB}}\,;\,\vec{\mparam{AC}}\right)=\mparam{alpha}$, $\mparam{AC}=\mparam{b}$,
  $\mparam{AB}=\mparam{c}$ et $ \left(\vec{\imath}\,;\,\vec{\mparam{AC}}\right)=\mparam{angle}$.
  % \compiletrue
  \begin{bvasy}{triangleAbc}
    import geometry;

    size(5cm);

    currentcoordsys=cartesiansystem(i=(1,0.5),j=(-0.25,.75));
    show(currentcoordsys);

    triangle t=triangleAbc(-60,2,3,angle=45,(1,1));
    show(Lb="2", Lc="3",t);
    markangle("$60^\circ$",t.C,t.A,t.B, Arrow);
  \end{bvasy}
\item \index{triangle(line,line,line)}
  \begin{Vcolor}
    triangle triangle(line l1, line l2, line l3)
  \end{Vcolor}
  Renvoie le triangle dont les côtés sont \param{l1}, \param{l2}
  et \param{l3}.
\end{itemize}

\hyperdef{subsection}{vertex}{\subsection{\index{sommet!triangle|mainidx}Sommets de triangles}}
Étant donné un objet \param{t} de type \code{triangle}, ses propriétés
\param{t.VA}, \param{t.VB} et \param{t.VC}, de type \code{vertex},
représentent les sommets du triangle \param{t}. \Geo implémente ainsi
des routines admettant comme paramètre un sommet de triangle sans avoir
à spécifier explicitement le triangle auquel il se réfère.

Par exemple, dans le code suivant, la routine
\hypertarget{bisectorvertex}{%
  \code{line bisector(vertex V, real angle=0)}}%
\index{bisector(vertex,real)} retourne l'image par la rotation
d'angle \param{angle} et de centre \param{V} de la première
bissectrice passant par \param{V}.
% \compiletrue
\begin{bvasy}{bisector_vertex}
  size(7cm); import geometry;
  triangle t=triangleabc(4,5,6);
  drawline(t, linewidth(bp));
  line ba=bisector(t.VA), bb=bisector(t.VB);
  line bc=bisector(t.VC); draw(ba^^bb^^bc);
  markangle((line) t.AB, (line) t.AC, StickIntervalMarker(2,1));
  markangle((line) t.BC, (line) t.BA, StickIntervalMarker(2,2));
  markangle((line) t.CA, (line) t.CB, StickIntervalMarker(2,3));
\end{bvasy}
Voici quelques routines et opérateurs élémentaires relatifs aux
objets de type \param{vertex}:
\begin{itemize}
\item \index{cast(vertex V)}
  \begin{Vcolor}
    point operator cast(vertex V)
  \end{Vcolor}
  Permet le \og{}casting\fg{} d'un objet de type \code{vertex} en
  objet de type \code{point}.
\item \index{point(explicit vertex V)}
  \begin{Vcolor}
    point point(explicit vertex V)
  \end{Vcolor}
  Renvoie l'objet de type \code{point} représenté par
  l'objet \param{V} de type \code{vertex}. Le code \code{point(V)} est
  équivalent au code \code{(point)V} qui force le \og{}casting\fg{} de
  \code{vertex} vers \code{point}.
\item \index{dir(vertex)}
  \begin{Vcolor}
    vector dir(vertex V)
  \end{Vcolor}
  Renvoie le vecteur unitaire porté par la première bissectrice de
  l'angle en \param{V} et orienté vers l'extérieur du triangle auquel
  se réfère \param{V}. Cette routine est particulièrement utile pour
  placer des labels aux sommets d'un triangle.
\end{itemize}
D'autres routines admettant comme paramètre un objet de type
\code{vertex} sont décrites dans la section suivante et conjointement
aux \href{#subsection.routines}{routines concernant les triangles}.

\hyperdef{subsection}{side}{\subsection{\index{côté!triangle|mainidx}Côtés de triangles}}
Étant donné un objet \param{t} de type \code{triangle}, ses propriétés
\param{t.AB}, \param{t.BC}, \param{t.CA}, \param{t.BA}, \param{t.AC}
et \param{t.CB}, de type \code{side},
représentent les côtés du triangle \param{t}. \Geo implémente ainsi
des routines admettant comme paramètre un côté de triangle sans avoir
à spécifier explicitement le triangle auquel le côté se réfère.

Par exemple, dans le code suivant, la routine
\hypertarget{excircleside}{\code{circle excircle(side s)}}\index{excircle(side)} retourne le
cercle exinscrit du triangle auquel se réfère \param{s} et tangent
à \param{s}.
% \compiletrue
\begin{bvasy}{excircle_intro}
  import geometry;
  size(6cm,0);

  triangle t=triangle((-1,0), (2,0), (0,2));

  drawline(t, linewidth(bp));
  label(t,alignFactor=4);

  clipdraw(excircle(t.AB), bp+0.8green);
  clipdraw(excircle(t.BC), bp+0.8green);
  clipdraw(excircle(t.AC), bp+0.8green);

  draw(box((-2.5,-3), (3.5,3.5)), invisible);
\end{bvasy}
Voici quelques routines et opérateurs élémentaires relatifs aux
objets de type \param{side}:
\begin{itemize}
\item \index{cast(side side)}
  \begin{Vcolor}
    line operator cast(side side)
  \end{Vcolor}
  Permet le \og{}casting\fg{} d'un objet de type \code{side} en
  objet de type \code{line}.
\item \index{line(explicit side side)}
  \begin{Vcolor}
    line line(explicit side side)
  \end{Vcolor}
  Renvoie l'objet de type \code{line} représenté par
  l'objet \param{side} de type \code{side}. Le code \code{line(S)} est
  équivalent au code \code{(line)S} qui force le \og{}casting\fg{} de
  \code{side} vers \code{line}.
\item \index{segment(explicit side side)}
  \begin{Vcolor}
    segment segment(explicit side side)
  \end{Vcolor}
  Renvoie l'objet de type \code{segment} représenté par
  l'objet \param{side} de type \code{side}. Le code \code{segment(S)} est
  équivalent au code \code{(segment)S} qui force le \og{}casting\fg{} de
  \code{side} vers \code{segment}.
\item \index{opposite(vertex)}
  \begin{Vcolor}
    side opposite(vertex V)
  \end{Vcolor}
  Renvoie le côté opposé à \param{V} dans le triangle auquel se réfère \param{V}.
\item \index{opposite(side)}
  \begin{Vcolor}
    vertex opposite(side side)
  \end{Vcolor}
  Renvoie le sommet opposé à \param{side} dans le triangle auquel se réfère \param{side}.
\end{itemize}
Les autres routines admettant comme paramètre un objet de type
\code{side} sont décrites conjointement aux
\href{#subsection.routines}{routines concernant les triangles}.

\subsection{Opérateurs}
Le seul opérateur s'appliquant aux objets de type \code{triangle} est
\index{*(transform,triangle)}
\begin{Vcolor}
  triangle operator *(transform T, triangle t)
\end{Vcolor}
\noindent qui autorise le code \code{transform*triangle}.

\hyperdef{subsection}{routines}{\subsection{Autres routines}}
\begin{itemize}
\item \index{orthocentercenter(triangle)}
  \begin{Vcolor}
    point orthocentercenter(triangle t)
  \end{Vcolor}
  Retourne l'orthocentre du triangle \param{t}.
\item \index{foot(vertex)}\index{foot(side)}
  \begin{Vcolor}
    point foot(vertex V)
  \end{Vcolor}
  Retourne le pied de la hauteur issue de \param{V}. La routine
  \code{point foot(side side)} est aussi disponible.
\item \index{altitude(vertex)}\index{altitude(side)}
  \begin{Vcolor}
    line altitude(vertex V)
  \end{Vcolor}
  Retourne la hauteur issue de \param{V}. La routine
  \code{line altitude(side side)} est aussi disponible.
\item \index{orthic(triangle)}
  \begin{Vcolor}
    triangle orthic(triangle t)
  \end{Vcolor}
  Retourne le triangle orthique de \param{t}; les sommets sont les pieds des hauteurs
  de \param{t}.
  \begin{bvasy}{orthic}
    size(8cm);
    import geometry;

    triangle t=triangleabc(3,4,6);
    drawline(t, linewidth(bp));
    line hc=altitude(t.AB), hb=altitude(t.AC);
    line ha=altitude(t.BC); draw(hc^^hb^^ha);
    dot("H", orthocentercenter(t));

    perpendicularmark(t.AB,hc,quarter=-1);
    perpendicularmark(t.AC,hb,quarter=-1);
    perpendicularmark(t.BC,ha);

    triangle ort=orthic(t);
    draw(ort,bp+0.8*green); dot(ort, 0.8*red);
    addMargins(1cm,1cm);
  \end{bvasy}
\item \index{midpoint(side)}
  \begin{Vcolor}
    point midpoint(side side)
  \end{Vcolor}
  Retourne le milieu de \param{side}.
\item \index{centroid(triangle)}
  \begin{Vcolor}
    point centroid(triangle t)
  \end{Vcolor}
  Retourne le centre de gravité du triangle \param{t}.
\item \index{median(vertex)}\index{median(side)}
  \begin{Vcolor}
    line median(vertex V)
  \end{Vcolor}
  Retourne la médiane issue de \param{V}. La routine
  \code{line median(side side)} est aussi disponible.
\item \index{medial(triangle)}
  \begin{Vcolor}
    triangle medial(triangle t)
  \end{Vcolor}
  Retourne le triangle dont les sommets sont les milieux de \param{t}.
  % \compiletrue
  \begin{bvasy}{medial}
    size(8cm);
    import geometry;

    triangle t=triangleabc(6,5,4);
    drawline(t, linewidth(bp));
    line ma=median(t.VA), mb=median(t.VB);
    line mc=median(t.VC); draw(ma^^mb^^mc);

    draw(segment(t.AB), StickIntervalMarker(2,1));
    draw(segment(t.BC), StickIntervalMarker(2,2));
    draw(segment(t.CA), StickIntervalMarker(2,3));

    triangle med=medial(t);
    draw(med,bp+0.8*green); dot(med, 0.8*red);
    addMargins(1cm,1cm);
  \end{bvasy}
\item \index{anticomplementary(triangle)}
  \begin{Vcolor}
    triangle anticomplementary(triangle t)
  \end{Vcolor}
  Retourne le triangle dont les milieux des côtés sont les sommets de \param{t}.
\item \index{bisector(vertex,real)}
  \begin{Vcolor}
    line bisector(vertex V, real angle=0)
  \end{Vcolor}
  Retourne l'image par la rotation d'angle \param{angle} et de
  centre \param{V} de la première bissectrice passant
  par \param{V}. Un exemple est donné \href{#bisectorvertex}{ci-avant}.
\item \index{bisectorpoint(side side)}
  \begin{Vcolor}
    point bisectorpoint(side side)
  \end{Vcolor}
  Retourne le point d'intersection de la première bissectrice de
  l'angle opposé à \param{side} avec \param{side}.
\item \index{bisector(side side)}
  \begin{Vcolor}
    line bisector(side side)
  \end{Vcolor}
  Retourne la médiatrice du segment représenté par \param{side}.
\item \index{circumcenter(triangle)}
  \begin{Vcolor}
    point circumcenter(triangle t)
  \end{Vcolor}
  Retourne le centre du cercle circonscrit au triangle \param{t}.
\item \index{circle(triangle)}\index{circumcircle(triangle)}
  \begin{Vcolor}
    circle circle(triangle t)
  \end{Vcolor}
  Retourne le cercle circonscrit au triangle \param{t}. La routine
  \code{circumcircle(triangle t)} en est un alias.
\item \index{tangential(triangle)}
  \begin{Vcolor}
    triangle tangential(triangle t)
  \end{Vcolor}
  Retourne le triangle dont les côtés sont tangents au cercle
  circonscrit à \param{t} et passent par ses sommets.
  % \compiletrue
  \begin{bvasy}{tangential}
    size(7cm); import geometry;
    triangle t=triangleabc(3,4,6);
    draw(t, linewidth(bp));
    clipdraw(circle(t), linewidth(bp));
    triangle itr=tangential(t);
    drawline(itr, bp+0.8*green); dot(itr, 0.8*red);
    line syma=line(itr.A,t.A), symb=line(itr.B,t.B);
    line symc=line(itr.C,t.C); draw(syma^^symb^^symc);
    dot("$K$", intersectionpoint(syma,symb),
    2*dir(-120));
    label(t,alignFactor=2,UnFill);
    label("$T_A$","$T_B$","$T_C$", itr, alignFactor=4,
    UnFill);
    addMargins(1cm,1cm);
  \end{bvasy}
\item \index{incenter(triangle)}
  \begin{Vcolor}
    point incenter(triangle t)
  \end{Vcolor}
  Retourne le centre du cercle inscrit dans le triangle \param{t}.
\item \index{inradius(triangle)}
  \begin{Vcolor}
    real inradius(triangle t)
  \end{Vcolor}
  Retourne le rayon du cercle inscrit dans le triangle \param{t}.
\item \index{incircle(triangle)}
  \begin{Vcolor}
    circle incircle(triangle t)
  \end{Vcolor}
  Retourne le cercle inscrit dans le triangle \param{t}.
\item \index{intouch(triangle)}
  \begin{Vcolor}
    triangle intouch(triangle t)
  \end{Vcolor}
  Retourne le triangle dont les sommets sont les points de contact du
  cercle inscrit à \param{t} avec \param{t}.
\item \index{intouch(side)}
  \begin{Vcolor}
    point intouch(side side)
  \end{Vcolor}
  Retourne le point de contact du côté \param{side} avec le cercle
  inscrit au triangle auquel se réfère \param{side}.
\item \index{gergonne(triangle t)}
  \begin{Vcolor}
    point gergonne(triangle t)
  \end{Vcolor}
  Renvoie le point de {\sc Gergonne} du triangle \param{t}.
  \begin{bvasy}{intouch}
    size(8.5cm,0);import geometry;
    triangle t=triangleabc(5,6,7);
    drawline(t, linewidth(bp));
    draw(incircle(t));
    triangle itr=intouch(t);
    draw(itr,bp+0.8*green); dot(itr, 0.8*red);
    point Ge=gergonne(t);
    dot("$G_e$", Ge, 2*dir(-10));
    draw(line(Ge,t.A), 0.8*green);
    draw(line(Ge,t.B), 0.8*green);
    draw(line(Ge,t.C), 0.8*green);
    addMargins(1cm,1cm);
  \end{bvasy}
\item \index{excenter(side)}
  \begin{Vcolor}
    point excenter(side side)
  \end{Vcolor}
  Retourne le centre du cercle exinscrit du triangle auquel se réfère \param{side}
  et tangent à \param{side}.
\item \index{exradius(side)}
  \begin{Vcolor}
    real exradius(side side)
  \end{Vcolor}
  Retourne le rayon du cercle exinscrit du triangle auquel se réfère \param{side}
  et tangent à \param{side}.
\item \index{excircle(side)}
  \begin{Vcolor}
    circle excircle(side side)
  \end{Vcolor}
  Retourne le cercle exinscrit du triangle auquel se réfère \param{side}
  et tangent à \param{side}.
\item \index{extouch(triangle)}
  \begin{Vcolor}
    triangle extouch(triangle t)
  \end{Vcolor}
  Retourne le triangle dont les sommets sont les points de contact des
  cercles exinscrit à \param{t} avec ses côtés.
\item \index{extouch(side)}
  \begin{Vcolor}
    point extouch(side side)
  \end{Vcolor}
  Retourne le point de contact du côté \param{side} avec le cercle
  exinscrit renvoyé par \code{excircle(side)}.
  % \compiletrue
  \begin{bvasy}{extouch}
    import geometry; size(6cm,0);

    triangle t=triangle((-1,0), (2,0), (0,2));
    drawline(t, linewidth(bp));
    label(t,alignFactor=4);

    circle c1=excircle(t.AB), c2=excircle(t.BC);
    circle c3=excircle(t.AC);
    clipdraw(c1, bp+0.8green);
    clipdraw(c2, bp+0.8green);
    clipdraw(c3, bp+0.8green);
    dot(c1.C^^c2.C^^c3.C, green);
    draw(extouch(t), bp+0.8green, dot);
  \end{bvasy}
\item \index{symmedian(triangle)}
  \begin{Vcolor}
    point symmedian(triangle t)
  \end{Vcolor}
  Retourne le point symédian (ou point de Lemoine) du triangle \param{t}.
\item \index{symmedian(side side)}
  \begin{Vcolor}
    point symmedian(side side)
  \end{Vcolor}
  Retourne le point symédian du côté \param{side}.
  % Return the \href{http://mathworld.wolfram.com/SymmedianPoint.html}{symmedian point} of \param{side}.
\item \index{symmedian(vertex V)}
  \begin{Vcolor}
    line symmedian(vertex V)
  \end{Vcolor}
  Retourne la droite
  \href{http://fr.wikipedia.org/wiki/Sym\%C3\%A9diane}{symédiane}
  passant par \param{V} du triangle auquel se réfère \param{V}.
  % \compiletrue
  \begin{vasy}{symmedian}
    import geometry; size(10cm,0);
    triangle t=triangle((-1,0), (2,0), (0,2)); drawline(t, linewidth(bp));
    label(t,alignFactor=2, alignAngle=90);
    triangle st=symmedial(t); draw(st, bp+0.8green);
    label("$A'$", "$B'$", "$C'$", st, alignAngle=45, 0.8green);
    line mA=median(t.VA); draw(mA, blue); dot("$M_A$",midpoint(t.BC), 1.5E, blue);
    draw(segment(t.BC), bp+blue, StickIntervalMarker(2,2,blue));
    line bA=bisector(t.VA); draw(bA, grey); dot("$B_A$", bisectorpoint(t.BC));
    line sA=symmedian(t.VA); draw(sA, 0.8*green);
    draw(symmedian(t.VB), 0.8*green); draw(symmedian(t.VC), 0.8*green);
    point sP=symmedian(t); dot("$K$", sP, 2*dir(125));
    markangle(sA, t.AC, radius=2cm, StickIntervalMarker(1,1));
    markangle(t.AB, mA, radius=2cm, StickIntervalMarker(1,1));
    markangle(mA, sA, radius=10cm, StickIntervalMarker(2,2));
  \end{vasy}
\item \index{cevian(side,point)}
  \begin{Vcolor}
    point cevian(side side, point P)
  \end{Vcolor}
  Renvoie le point de \textsc{Cevian} de \param{P} appartenant au côté \param{side}.
\item \index{cevian(triangle,point)}
  \begin{Vcolor}
    triangle cevian(triangle t, point P)
  \end{Vcolor}
  Renvoie le
  \href{http://mathworld.wolfram.com/CevianTriangle.html}{triangle de
    \textsc{Cevian}} relatif à \param{P}.
\item \index{cevian(vertex,point)}
  \begin{Vcolor}
    line cevian(vertex V, point P)
  \end{Vcolor}
  Renvoie la droite de \textsc{Cevian} relative à \param{P}, passant
  par \param{V} dans le triangle auquel se réfère \param{V}.

  L'exemple suivant illustre la propriété \og{}\emph{si un
    triangle $A'B'C'$ est un triangle de \textsc{Cevian} d'un triangle
    $ABC$ alors le triangle $A''B''C''$, dont les sommets sont les symétriques de
    $A'$, $B'$ et $C'$ par rapport aux milieux des côtés respectifs,
    est aussi un triangle de \hypertarget{cevian_ex}{\textsc{Cevian}}}\fg{}
  % \compiletrue
  \begin{vasy}{cevian}
    import geometry; size(10cm,0);
    triangle t=triangleabc(5,6,7); label(t); draw(t, linewidth(bp));
    point P=0.6*t.B+0.25*t.C; dot("$P$", P, dir(60), 0.8*red);
    triangle C1=cevian(t, P);
    label("$A'$","$B'$","$C'$", C1, 0.8*red); draw(C1, bp+0.8*red, dot);
    draw(t.A--C1.A, 0.8*red); draw(t.B--C1.B, 0.8*red); draw(t.C--C1.C, 0.8*red);

    point Ma=midpoint(t.BC), Mb=midpoint(t.AC), Mc=midpoint(t.BA);
    dot("$M_1$",Ma,-dir(t.VA)); dot("$M_2$",Mb,-dir(t.VB)); dot("$M_3$",Mc,-dir(t.VC));
    draw(t.A--Ma^^t.B--Mb^^t.C--Mc, grey); dot("$G$", centroid(t), 2*dir(-65), grey);

    point App=rotate(180,Ma)*C1.A, Bpp=rotate(180,Mb)*C1.B, Cpp=rotate(180,Mc)*C1.C;
    draw(C1.A--App, 0.8*green, StickIntervalMarker(2,1,0.8*green));
    draw(C1.B--Bpp, 0.8*green, StickIntervalMarker(2,2,0.8*green));
    draw(C1.C--Cpp, 0.8*green, StickIntervalMarker(2,3,0.8*green));

    triangle C2=triangle(App,Bpp,Cpp);
    label("$A''$","$B''$","$C''$", C2, 0.8*blue); draw(C2, bp+0.8*blue, dot);
    segment sA=segment(t.A,C2.A), sB=segment(t.B,C2.B);
    point PP=intersectionpoint(sA,sB);
    dot("$P'$", PP, dir(100), 0.8*blue);
    draw(sA, 0.8*blue); draw(sB, 0.8*blue); draw(segment(t.C,C2.C), 0.8*blue);
  \end{vasy}
\item \index{isotomic(vertex,point)}
  \begin{Vcolor}
    line isotomic(vertex V, point M)
  \end{Vcolor}
  Renvoie la
  \href{http://mathworld.wolfram.com/IsotomicLines.html}{droite
    isotomique} passant par \param{V} et relative à \param{M} dans le
  triangle auquel se réfère \param{V}.
\item \index{isotomicconjugate(triangle,point)}
  \begin{Vcolor}
    point isotomicconjugate(triangle t, point M)
  \end{Vcolor}
  Renvoie le
  \href{http://mathworld.wolfram.com/IsotomicLines.html}{conjugué
    isotomique} de \param{M} relativement à \param{t}.
\item \index{isotomic(side,point)}
  \begin{Vcolor}
    point isotomic(side side, point M)
  \end{Vcolor}
  Renvoie le point d'intersection de la
  \href{http://mathworld.wolfram.com/IsotomicLines.html}{droite
    isotomique} de \param{M}, relativement au triangle auquel se
  réfère \param{side}, avec le côté \param{side}.
\item \index{isotomic(triangle,point)}
  \begin{Vcolor}
    triangle isotomic(triangle t, point M)
  \end{Vcolor}
  Renvoie le triangle dont les sommets sont les points d'intersection
  des droites isotomiques relatives à \param{M} dans \param{t} avec les
  côtés de \param{t}. Ainsi, dans \href{#cevian_ex}{la figure
    précédente}, le triangle $A''B''C''$ est le triangle isotomique
  relatif à \param{P}.

  Ci-dessous, la même figure obtenue à l'aide des routines
  \code{isotomic} gagne en concision.
  % \compiletrue
  \begin{vasy}{isotomic}
    import geometry; size(10cm,0);
    triangle t=triangleabc(5,6,7); label(t); draw(t, linewidth(bp));
    point P=0.6*t.B+0.25*t.C; dot("$P$", P, dir(60), 0.8*red);
    draw(segment(isotomic(t.VA,P))^^segment(isotomic(t.VB,P))^^segment(isotomic(t.VC,P)),
    0.8*blue);
    draw(segment(cevian(t.VA,P))^^segment(cevian(t.VB,P))^^segment(cevian(t.VC,P)),
    0.8*red);
    triangle t1=cevian(t,P); label("$P_1$", "$P_2$", "$P_3$", t1); draw(t1, bp+0.8*red);
    triangle t2=isotomic(t,P); label("$Q_1$", "$Q_2$", "$Q_3$", t2); draw(t2, bp+0.8*blue);
    dot("$Q$", isotomicconjugate(t,P), dir(100), 0.8*blue);

    point Ma=midpoint(t.BC), Mb=midpoint(t.AC), Mc=midpoint(t.BA);
    dot("$M_1$",Ma,-dir(t.VA)); dot("$M_2$",Mb,-dir(t.VB)); dot("$M_3$",Mc,-dir(t.VC));
    draw(t.A--Ma^^t.B--Mb^^t.C--Mc, grey); dot("$G$", centroid(t), 2*dir(-65), grey);
    draw(t1.A--t2.A, 0.8*green, StickIntervalMarker(2,1,0.8*green));
    draw(t1.B--t2.B, 0.8*green, StickIntervalMarker(2,2,0.8*green));
    draw(t1.C--t2.C, 0.8*green, StickIntervalMarker(2,3,0.8*green));
  \end{vasy}
\item \index{isogonalconjugate(triangle,point)}
  \begin{Vcolor}
    point isogonalconjugate(triangle t, point M)
  \end{Vcolor}
  Renvoie le
  \href{http://fr.wikipedia.org/wiki/Conjugu\%C3\%A9_isogonal#Point_conjugu.C3.A9_isogonal}{conjugué
    isogonal} de \param{M} relativement à \param{t}.
  % Return the
  % \href{http://mathworld.wolfram.com/IsogonalConjugate.html}{isogonal
  %   conjugate} of \param{M} with respect to \param{t}.
\item \index{isogonal(side,point)}
  \begin{Vcolor}
    point isogonal(side side, point M)
  \end{Vcolor}
  Renvoie le point d'intersection de la
  \href{http://mathworld.wolfram.com/IsogonalLine.html}{droite
    isogonale} de \param{M}, relativement au triangle auquel se
  réfère \param{side}, avec le côté \param{side}.
\item \index{isogonal(triangle,point)}
  \begin{Vcolor}
    triangle isogonal(triangle t, point M)
  \end{Vcolor}
  Renvoie le triangle dont les sommets sont les points d'intersection
  avec les côtés de \param{t} des droites isogonales relatives
  à \param{M} dans \param{t}.\\
  L'exemple suivant illustre la propriété \og{}les triangles podaires de
  deux points isogonaux $P$ et $Q$ sont inscrits dans un même cercle de
  centre le milieu de $[PQ]$\fg{}.
  % \compiletrue
  \begin{vasy}{isogonaux}
    import geometry; size(10cm,0);
    triangle t=triangleabc(5,6,7); draw(t, linewidth(bp));
    point P=0.5*t.B+0.3*(t.C-t.B); dot("$P$", P, N, 0.8*red);

    point Q=isogonalconjugate(t,P); dot("$Q$", Q, dir(-30));
    point Q1=projection(t.AB)*Q; segment sq1=segment(Q,Q1);
    point Q2=projection(t.BC)*Q; segment sq2=segment(Q,Q2);
    point Q3=projection(t.AC)*Q; segment sq3=segment(Q,Q3);
    draw(sq1); draw(sq2); draw(sq3);
    dot("$Q_1$", Q1, SE); dot("$Q_2$", Q2); dot("$Q_3$", Q3, NW);

    point P1=projection(t.AB)*P; segment sp1=segment(P,P1);
    point P2=projection(t.BC)*P; segment sp2=segment(P,P2);
    point P3=projection(t.AC)*P; segment sp3=segment(P,P3);
    draw(sp1, 0.8*red); draw(sp2, 0.8*red); draw(sp3, 0.8*red);
    dot("$P_1$",P1,SW,0.8*red); dot("$P_2$",P2,0.8*red); dot("$P_3$",P3,NW,0.8*red);

    perpendicularmark(t.AB,sq1); perpendicularmark(t.BC,sq2);
    perpendicularmark(reverse(t.AC),sq3); perpendicularmark(t.AB,sp1, red);
    perpendicularmark(t.BC,sp2, red); perpendicularmark(reverse(t.AC),sp3, red);

    circle C=circle(Q1,Q2,Q3); draw(C, 0.8*blue);
    draw(segment(Q,P), 0.8*blue, StickIntervalMarker(2,2, 0.8*blue));
    dot("$C$", C.C, S, 0.8*blue);
  \end{vasy}
\item \index{fermat(triangle)}
  \begin{Vcolor}
    point[] fermat(triangle t)
  \end{Vcolor}
  Renvoie les
  \href{http://mathworld.wolfram.com/FermatPoints.html}{points de
    \textsc{Fermat}} du triangle \param{t}.
\item \index{pedal(triangle,point)}
  \begin{Vcolor}
    triangle pedal(triangle t, point M)
  \end{Vcolor}
  Renvoie le
  \href{http://fr.wikipedia.org/wiki/Conjugu\%C3\%A9_isogonal#Triangle_podaire}{triangle
    podaire} par rapport à \param{M} dans \param{t}.
\item \index{pedal(side side, point M)}
  \begin{Vcolor}
    line pedal(side side, point M)
  \end{Vcolor}
  Renvoie la droite passant pas \param{M} et par le projeté
  orthogonal de \param{M} sur le côté \param{side}.\\
  L'exemple suivant montre quelques droites de {\sc Simson}; on
  remarquera l'utilisation des méthodes \code{t.side(int)} et
  \code{t.vertex(int)} qui permettent de récupérer par leurs numéros les
  côtés et les sommets du triangle \param{t}.
  % \compiletrue
  \begin{bvasy}{simson}
    import geometry; size(8cm,0);
    triangle t=triangleabc(5,6,7);
    label(t, alignFactor=4);
    drawline(t, linewidth(bp));
    circle C=circle(t); draw(C, bp+dashed);
    pen[] p=new pen[] {0.8*red,0.8*blue,
      0.8*green, 0.8*yellow};
    for (int i=0; i < 4; ++i) {
      real x=35+i*90; point P=angpoint(C,x);
      dot("$P_"+(string)i+"$",P,dir(x),p[i]);
      for (int j=1; j < 4; ++j) {
        segment Sg=segment(pedal(t.side(j),P));
        draw(Sg,p[i]);
        markrightangle(P,Sg.B,t.vertex(j),p[i]);
      }
      drawline(pedal(t,P), bp+p[i]);
    }
    addMargins(1cm,1cm);
  \end{bvasy}
  % \compiletrue
\item \index{antipedal(triangle,point)}
  \begin{Vcolor}
    triangle antipedal(triangle t, point M)
  \end{Vcolor}
  Renvoie le triangle dont le triangle podaire par rapport à \param{M}
  est \param{t}.
  \begin{bvasy}{antipedal}
    import geometry; size(10cm,0);
    triangle t=triangleabc(5,6,7);
    label(t); draw(t, linewidth(bp));
    point P=0.5*t.B+0.3*t.C;
    dot("$P$", P, 2*dir(60));

    triangle Pt=pedal(t,P);
    currentpen=0.8*blue; draw(Pt);
    segment psA=segment(P,Pt.A);
    segment psB=segment(P,Pt.B);
    segment psC=segment(P,Pt.C);
    draw(psA); draw(psB); draw(psC);
    perpendicularmark(t.BC,psA);
    perpendicularmark(t.CA,psB);
    perpendicularmark(t.AB,psC);

    triangle APt=antipedal(t, P);
    currentpen=0.8*red; draw(APt);
    segment apsA=segment(P,t.A);
    segment apsB=segment(P,t.B);
    segment apsC=segment(P,t.C);
    draw(apsA); draw(apsB); draw(apsC);
    perpendicularmark(APt.BC,apsA);
    perpendicularmark(APt.CA,apsB);
    perpendicularmark(APt.AB,apsC);
  \end{bvasy}
\end{itemize}

\hyperdef{subsection}{trilinear}{\subsection{\index{trilinéaires!coordonnées|mainidx}%
    \index{coordonnées trilinéaires!triangle|mainidx}Coordonnées trilinéaires}}
Le type \code{trilinear}, dont la structure est donnée ci-après,
permet d'instancier un objet représentant les
\href{http://mathworld.wolfram.com/TrilinearCoordinates.html}{coordonnées
  trilinéaires} \shorthandoff{:}\param{a:b:c}\shorthandon{:} par
rapport au triangle~\param{t}.
\begin{center}
  \begin{Vcolor}
    struct trilinear
    {
      real a,b,c;
      triangle t;
    }
  \end{Vcolor}
\end{center}

Pour définir les coordonnées trilinéaires
\shorthandoff{:}\param{a:b:c}\shorthandon{:} par rapport à un
triangle \param{t} on peut utiliser la routine
\index{trilinear(triangle,real,real,real)}
\begin{Vcolor}
  trilinear trilinear(triangle t, real a, real b, real c)
\end{Vcolor}
Il est aussi possible de récupérer les coordonnées trilinéaires d'un
point grâce à la routine
\index{trilinear(triangle,point)}
\begin{Vcolor}
  trilinear trilinear(triangle t, point M)
\end{Vcolor}
Il est enfin possible de définir des coordonnées trilinéaires grâce à
une
\href{http://mathworld.wolfram.com/TriangleCenterFunction.html}{fonction
  de centre de triangle} $f$ et trois
paramètres \param{a}, \param{b} et \param{c} en utilisant à la routine
suivante\index{trilinear(triangle,centerfunction,real,real,real)}:
\begin{Vcolor}
  trilinear trilinear(triangle t, centerfunction f,
  real a=t.a(), real b=t.b(), real c=t.c())
\end{Vcolor}
\noindent où le type \code{centerfunction} représente une fonction
réelle à trois variables réelles.

La conversion d'un objet de type \code{trilinear} en type \code{point}
peut s'effectuer, comme d'habitude, de deux façon: avec la routine
\code{point(trilinear)} ou par la syntaxe de \og{}casting\fg{}
\code{(point) trilinear}.

Par exemple, en utilisant les
\href{http://mathworld.wolfram.com/IsotomicConjugate.html}{coordonnées
  trilinéaires du conjugués isotomique} d'un point, voici comment est
définie la routine \code{isotomicconjugate}:
\begin{Vcolor}
  point isotomicconjugate(triangle t, point M)
  {
    trilinear tr=trilinear(t,M);
    return point(trilinear(t,1/(t.a()^2*tr.a),1/(t.b()^2*tr.b),1/(t.c()^2*tr.c)));
  }
\end{Vcolor}

\hyperdef{section}{inversion}{\section{\index{triangle|mainidx}Inversions}}
Le type \code{inversion}, dont la structure est donnée ci-après,
permet d'instancier
l'\href{http://mathworld.wolfram.com/Inversion.htm}{inversion}
de pôle \param{C} et de puissance \param{k}
\begin{center}
  \begin{Vcolor}
    struct inversion
    {
      point C;
      real k;
    }
  \end{Vcolor}
\end{center}
\subsection{Définir une inversion}
Les routines et opérateurs suivants permettent de définir une
inversion.
\begin{itemize}
\item \index{inversion(real,point)}\index{inversion(point,real)}
  \begin{Vcolor}
    inversion inversion(real k, point C)
  \end{Vcolor}
  Renvoie l'inversion de pôle \param{C} et de puissance \param{k}. La
  routine \code{inversion(point C, real k)} est aussi disponible.
\item \index{inversion(circle,circle,real)}
  \begin{Vcolor}
    inversion inversion(circle c1, circle c2, real sgn=1)
  \end{Vcolor}
  \begin{itemize}
  \item si \param{sgn} est non nul, cette routine renvoie
    l'inversion dont la puissance est du signe de \param{sgn} et
    transformant \param{c1} en \param{c2};
  \item si \param{sgn} est nul, cette routine renvoie l'inversion
    centrée au pied de l'axe radical et laissant globalement
    invariants chacun des deux cercles \param{c1} et \param{c2}.
  \end{itemize}
  \href{#exemple_inversion}{Un exemple} utilisant cette routine a déjà
  été donné.
\item \index{inversion(circle,circle,circle)}
  \begin{Vcolor}
    inversion inversion(circle c1, circle c2, circle c3)
  \end{Vcolor}
  Renvoie l'inversion laissant globalement invariants les trois
  cercles \param{c1}, \param{c2} et \param{c3}.
\item \index{cast(inversion)}\index{circle(inversion)}
  \begin{Vcolor}
    circle operator cast(inversion i)
  \end{Vcolor}
  Permet le \og{}casting\fg{} d'un objet de type \code{inversion} en
  \code{circle}. Le cercle renvoyé est le cercle directeur (ou principal)
  de \param{i}.\\
  On peut aussi forcer le \og{}casting\fg{} grâce à la routine
  \code{circle circle(inversion i)}.
\item \index{cast(circle)}\index{inversion(circle)}
  \begin{Vcolor}
    inversion operator cast(circle c)
  \end{Vcolor}
  Permet le \og{}casting\fg{} d'un objet de type \code{circle} en
  \code{inversion}. L'inversion renvoyée laisse globalement
  invariant \param{c}, a pour pôle le centre de \param{c} et le signe
  de la puissance est celui du rayon de \param{c}.\\
  On peut aussi forcer le \og{}casting\fg{} grâce à la routine
  \code{inversion inversion(circle c)}.
  \subsection{Appliquer une inversion}
  Les opérateurs suivants autorisent les codes du type
  \code{inversion*objet} qui renvoient l'image par \param{inversion} de
  l'objet \param{objet}.
\item \index{*(inversion,point)}
  \begin{Vcolor}
    point operator *(inversion i, point P)
  \end{Vcolor}
\item \index{*(inversion,line)}
  \begin{Vcolor}
    circle operator *(inversion i, line l)
  \end{Vcolor}
\item \index{*(inversion,circle)}
  \begin{Vcolor}
    circle operator *(inversion i, circle c)
  \end{Vcolor}
\item \index{*(inversion,segment)}
  \begin{Vcolor}
    arc operator *(inversion i, segment s)
  \end{Vcolor}
\item \index{*(inversion,triangle)}
  \begin{Vcolor}
    path operator *(inversion i, triangle t)
  \end{Vcolor}
\end{itemize}

On notera que l'inverse d'un cercle ou d'une droite peut être une
droite. Dans ce cas le cercle \param{C} renvoyé a un rayon infini et
la propriété \param{C.l} de type \code{line} est initialisée à la
valeur adéquate; les routines admettant ce cercle comme paramètre
utiliseront \param{C.l} à la place comme le montre l'exemple
suivant.
\begin{bvasy}{inversion_circle_droite}
  import geometry;
  size(4cm);

  circle C=circle((point)(0,0),1);
  draw(C, linewidth(bp));

  point O=dir(45);
  dot("$O$",O);

  inversion inv=inversion(3,O);
  circle Cp=inv*C;
  draw(Cp);

  dot(intersectionpoints(C,Cp), red);
\end{bvasy}
\emph{Cette fonctionnalité, rajoutée récemment, a été testée
  sommairement. Merci d'envoyer un rapport de bogue en cas de
  problème.}
\subsection{Exemples}
\href{#exemple_inversion}{Des exemples} qui
utilisent les inversions ont déjà été donnés, en voici d'autres.

Commençons par illustrer l'utilisation d'un cercle, ici le cercle
inscrit à un triangle, en tant qu'inversion:
\begin{bvasy}{circle_inversion}
  import geometry;
  size(6cm,0);

  triangle t=triangleabc(4,5,6);
  circle C=circumcircle(t), inC=incircle(t);

  draw(inC, bp+0.8*red);
  draw(C, bp+0.8*blue);
  draw(t, linewidth(bp));

  draw(inC*t, linewidth(bp));
  draw(inC*C, bp+0.8*blue);
\end{bvasy}
Ci-dessous la construction du collier de {\sc Pappus}.
\begin{bvasy}{pappus_construct}
  import geometry; size(7cm,0);
  inversion inv=inversion(10,(-4,0));
  line l1=line((-1,0),(-1,1)), l2=line((1,0),(1,1));
  draw(l1, bp+0.8*blue); draw(l2, bp+0.8*green);
  clipdraw(inv*l1,bp+0.8*blue);
  clipdraw(inv*l2,bp+0.8*green);
  int n=10;
  for (int i=0; i <= n; ++i) {
    circle C=circle((point)(0,2*i),1);
    circle Cp=inv*C;
    draw(Cp,bp+(1-abs(i/4))*red);
    if(abs(i) < 4){
      draw(C,bp+(1-abs(i/4))*red);
      draw((1,2*i)--inv*(1,2*i),0.8*green);
      draw((-1,2*i)--inv*(-1,2*i),0.8*blue);
    }
  }
  addMargins(1mm,1mm);
\end{bvasy}
On peut ainsi facilement en obtenir une belle représentation:
\begin{bvasy}{chaine_pappus}
  import geometry; size(8cm);

  inversion inv=inversion(1,(-4.5,0));
  path g1=inv*line((-1,0),(-1,1)),
  g2=inv*line((1,0),(1,1));
  fill(g1,lightgrey); draw(g1,linewidth(bp));
  unfill(g2); draw(g2,linewidth(bp));

  int n=40;
  for (int i=-n; i <= n; ++i) {
    path g=inv*circle((point)(0,2*i),1);
    fill(g,(1-abs(i)/n)*yellow);
    draw(g,bp+red); draw(g,blue);
  }
  shipout(bbox(5mm,Fill(rgb(0.95,0.95,0.8))));
\end{bvasy}
La figure suivante, où les droites ne sont pas parallèles, en est
une variante:
% \compiletrue
\begin{vasy}{pappus_variante}
  import geometry; size(8cm,0);
  point P=(0,-4.5); dot(P); inversion inv=inversion(1,P);
  line l1=line((0,0),(1,0.35)), l2=line((0,0),(-1,0.35));
  path g1=inv*l1, g2=inv*l2;
  fill(g1^^g2,evenodd+lightgrey); draw(g1,linewidth(bp)); draw(g2,linewidth(bp));

  for (int i:new int[]{-1,1}) {
    point P=(i*0.1,0); triangle t=triangle(shift(P)*vline,l1,l2); int n=15;
    for (int j=0; j <= n; ++j) {
      circle C=excircle(t.AB);
      t=triangle(shift(angpoint(C,(i-1)*90))*vline,l1,l2);
      circle Cp=inv*C; path g=Cp; fill(g,0.95*yellow); draw(g,bp+red); draw(g,blue); }}
  shipout(bbox(5mm,Fill(rgb(0.95,0.95,0.8))));
\end{vasy}

\hypertarget{inversion_damier}{La figure} suivante est l'image d'un
damier $12\times{}12$ par l'inversion dont le centre est proche \og{}du
centre du damier\fg{} et de rapport $1$.
% \compiletrue
\begin{vasy}{inversion_damier}
  import geometry;
  size(10cm,0);
  int n=12; segment[] S;
  inversion inv=inversion(1,(n/2+0.45,n/2+0.45));
  transform tv=shift(0,1), th=shift(1,0);
  for (int i=0; i < n; ++i)
  for (int j=0; j < n; ++j) {
    for (int l=0; l < 4 ; ++l)
    S[l]=segment(point(tv^i*th^j*unitsquare,l), point(tv^i*th^j*unitsquare,(l+1)%4));
    path g;
    for (int l=0; l < 4; ++l) g=g--(path)(inv*S[l]);
    g=g--cycle;
    if((i+j)%2 == 0)  draw(g); else fill(g);
  }
\end{vasy}

\newpage
\section{Index}
\printindex
\end{document}